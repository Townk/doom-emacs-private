#+TITLE: Thiago's Emacs Configuration
#+SUBTITLE: A detailed setup for Emacs using Doom Emacs framework
#+AUTHOR: Thiago Alves
#+EMAIL: thiago@rapinialves.com
#+DATE: Fri, Jan 1 2021

#+language: en
#+startup: num
#+property: header-args :mkdirp yes
#+property: header-args:emacs-lisp :comments link :shebang ";;; -*- lexical-binding: t; -*-\n"
#+property: header-args:snippet :padline no
#+setupfile: assets/html-export.setup

* Prologue
Hello there! Thanks for checking my Emacs configuration. I decided to go with a literate configuration to try to contribute back to this community that is always available to help me when I have any question about Emacs.

This configuration uses [[https://github.com/hlissner/doom-emacs][Doom Emacs]] (from now on, referred as Doom) as its base, so, my suggestion to you is to get familiarized with it *before* diving deep into this configuration (a good starting point is the [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org][Getting Started]] page on the official repository), there will be options, functions, and variables I will use without much explanation, because they're some sort of /common knowledge/ in the Doom's community.

Also, when you install Doom for the first time, it creates the =config.el= and =packages.el= files for you, containing some useful doc-strings there. In this version of my configuration, I will try to include as much of those comments as possible in the form of /free text/, so I want you to remember that I didn't come up with those words, some folks much smarter than me did, so feel free to [[https://liberapay.com/hlissner][thank]] the Doom's [[https://paypal.me/henriklissner][creator]].

#+caption: $DOOMDIR/From the =config.el= file comments
#+begin_note
In your journey configuring Emacs the way you want, you might need to use more functions then I'm using in this configuration. Here are some additional functions or macros that could help you configure Doom:

- ~load!~ for loading external =*.el= files relative to =$DOOMDIR/config.el=;
- ~use-package!~ for configuring packages;
- ~after!~ for running code after a package has loaded;
- ~add-load-path!~ for adding directories to the ~load-path~, relative to =$DOOMDIR/config.el=. Emacs searches the ~load-path~ when you load packages with ~require~ or ~use-package~;
- ~map!~ for binding new keys;

To get information about any of these functions or macros, move the cursor over the highlighted symbol at press '=K=' (non-evil users must press '=C-c g k='). This will open documentation for it, including demos on how to use them.

You can also try '=gd=' (or '=C-c g d=') to jump to their definition and see their source code.
#+end_note

** About this document
The organization of my Emacs configuration tries to structure the design and build of a text editor tailored for my needs.

Some of these needs are technology related (e.g. programming languages, diagrams tooling, etc.), while others are aesthetic or productivity related.

I want to stress out to the reader, that you are, ultimately, reading a personal opinion, and what works for me may or may not work for you.

I intend to start with features I consider common to any text editor, then, I'll go into some personal preferences, still related to text editor in general. Once I'm done with the common features, I'll configure Emacs for writing prose. I decided to do all my prose writing using [[https://orgmode.org/][Org Mode]], so I will focus the configuration at that point, to adjust Emacs and Org to fit my personal workflow.

After configuring Emacs for writing prose, I will focus this document on programming (which is what I do for work). I will cover [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][Emacs Lisp]], [[https://www.javascript.com/][Javascript]]/[[https://www.typescriptlang.org/][Typescript]], [[https://kotlinlang.org/][Kotlin]], [[https://www.python.org/][Python]], [[https://www.shellscript.sh/][Shell Script]], and [[https://developer.apple.com/swift/][Swift]]. Some in more details then others, but at a minimum, I want Emacs to open files of those languages without errors or wrong syntax highlight.

Overall, my intention is to make changes on Doom and core Emacs to get consistent keybindings and behaviors, so that when you learn to use one part of my configuration, you will feel comfortable on the other parts.

** About literate configuration
A long time ago I found out about [[http://literateprogramming.com][Literate Programming]] when I read my first Emacs configuration with Org Mode. It was the [[https://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] of [[https://sachachua.com/blog/about/][Sacha Chua]], which I have to say, it was a fantastic reading. I tried couple times to do the same with past configurations without much success.

I believe the mentality shift happened when I finally decided to read the original paper about [[http://literateprogramming.com/knuthweb.pdf][Literate Programming]] by [[https://www-cs-faculty.stanford.edu/~knuth/][Donald E. Knuth]], and just like that, I want to practice Literate Programming on about everything I do.

Since this document is about a text editor configuration, I have to highlight couple differences between Mr. Knuth's Literate Programming and my Literate Configuration.

The core difference, is the fact that each piece of code in this document may not be a self contained snippet. When I find appropriate, I will split big block of code into multiples blocks separated by text used to explain the rational behind the snippet in question. So, if you're following this document and copying some snippets, make sure you include the /close parenthesis/ that these split sections contain.

** Acknowledgments
Besides the already mentioned [[https://sachachua.com/blog/about/][Sacha Chua]], I would also like to thank Timothy (a.k.a. [[https://github.com/tecosaur][tecosaur]]) for his wonderful literate config. I would be lying if I said [[https://www.gitmemory.com/tecosaur][tecosaur]] was not one of the big reasons for me to give it a second try on my literate config, so thank you mate! Feel free to say that this configuration is a byproduct of yours.

I would also like to thank [[https://github.com/gongzhitaao][Zhitao Gong]] for the amazing theme I'm using in this publication, it's called [[https://github.com/gongzhitaao/orgcss][OrgCSS]] and you should definitely check it out. If you try [[https://github.com/gongzhitaao][Zhitao Gong]]'s theme and it does not look like this, you can use my extra modification by adding the following on your Org preamble:

#+begin_src org :tangle no
,#+setupfile: https://townk.github.io/doom-emacs-private/assets/html-export.setup
#+end_src

Last, but not least, I like to give a shout to [[https://github.com/justinbondoc][Justin Bondoc]] for his CSS tutorial on "[[https://www.madcapsoftware.com/blog/css-tip-creating-styled-boxes-notes-warnings-examples-tips/][Creating Styled Boxes for Notes, Warnings, Examples, and Tips]]". You will notice that I not only got his CSS here, but also his icons for the note and warning boxes!

** Investigating issues
If you, like me, try new things with your config until it breaks, is important that we have some tools to help us figure out what is going on. Regardless if you'll use this configuration /ipsis litteris/, or start yours from scratch, and copy the tidbits that may interest you. Before you start know these things:

To get a better sense of what is going on, start Emacs from terminal with the =--debug-init= flag:

#+caption: Command to start emacs in debug mode
#+begin_src shell :tangle no
emacs --debug-init
#+end_src

This will stop Emacs on the first error and print the stack trace for it. As of now, this might not useful beyond reporting bugs, nevertheless, it's important you keep it in your mind!

Another issue that may show up, is slowness, specially after adding packages. This is not uncommon since Emacs startup time is sensible to package loading.

What I recommend to do, is to install a package that specializes on benchmarking, and use it, when you have the need:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! benchmark-init)
#+end_src

Check my =init.el= file on the [[Appendix][Appendix]], to see how I hook up benchmarking to the =--debug-init= flag.

After starting Emacs with the =--debug-init= flag, you can check the call tree with the =M-x benchmark-init/show-durations-tree= command.

* Standard features
Before jumping in the configuration itself, I like to describe what I'm trying to achieve on each section, so the reader don't feel lost. Also, by defining good requirements, this document may help someone else to achieve similar results with different editors. If you are among the crazies that besides liking my choices, decided to port this to other editor, drop me a line, I'll be more than happy to link your document here.

** Requirements
As mentioned on section [[About this document]], this part of the document will deal with configurations and functionalities that I consider as essential on any text editor, from IDEs to editors like [[https://en.wikipedia.org/wiki/Microsoft_Notepad][Notepad]], even though they're not present in all editors.

*** Fast start
Although this seams like the biggest /no-brainer/ of my requirements, it would be funny if was not sad the fact that Emacs is the worst in this category when loaded with plugins (from here on, referred as /packages/) compared to editors of the same caliber (e.g. [[https://www.vim.org/][Vim]], [[https://www.sublimetext.com][Sublime Text]], [[https://code.visualstudio.com/][Visual Studio Code]], etc.). I personally believe that Emacs compensate with its power, nevertheless, I still want to have an editor that opens on a snap when I need.

By default, Doom starts a fresh emacs process fast, but it take its sweet time to open a buffer depending on the buffer's type and the amount of packages you have available. For sake of being able to have a functional editor with all my requirements, I will say that I have just the requirement of starting it in less than 1.8 seconds. Eventually I will address the other part of this equation (probably using =emacsclient= or some type of memory snapshot).

*** Modal editing
I need to come clean to the reader about my past experiences with text editors. I'm a /die-hard/ Vim user, even though I'm not using Vim for some tim now. Nevertheless, I personally believe that modal editing is far superior way to use a text editor than any other alternative, and that is why I consider /modal editing/, a feature that any text editor should have.

*** Text Snippets
Although I'm not an avid user of snippets, I believe they're a fundamental part of modern editors. Without them, I have to resort to some book keeping method to save interesting coding snippets. So, I consider snippets a base requirement for my editor.

*** Inline completion
Also know as /intellisence/, or /code complete/ in other editors and IDEs, /at-point completion/ are those popups that show up when you type, with possible completions for what you're doing. My editor should also offer such feature, but it must play well with modal editing (if I leave the /Insert Mode/ the popup should close), and snippets (snippet expansion keywords have precedence over skipping to the next line with the =<TAB>= key).

*** Automatic indentation
Here I'm not talking about indent after pressing '=RET='. I'm talking about re-indenting the file as I change it. On the Emacs world, this is also known as /electric indent/.

I understand that in some occasions this process may slow down the editor, so I will define here that I want the whole indentation to change when I change the total number of lines on the file.

*** Smart backspace
When I'm editing a file (usually a source code), in some scenarios, the editor helps me out by inserting text that I want. One example of this is the closing pair character. If I type a ' ="= ', Doom will add a second one after my cursor. In most of the scenarios, to revert what just happened, I press =<BACKSPACE>=, and I get the same state I was before pressing the key that generated the completion.

But there is one case where this does not happen, which is when Doom adds a paired new line when I press =<ENTER>= after open a pair. The net effect of this completion, is to have the cursor on the next line, indented correctly. But when I immediately press =<BACKSPACE>=, Doom deletes the indentation and that's it.

This requirement, is to make sure the =<BACKSPACE>= key behaves in the same way when we use it after a completion.

*** Balanced pairs
The common behavior you might see on text editors is to complete a character pair as you type. For instance, if you type an open parenthesis, the editor would insert the closing one automatically, and if you press the closing parenthesis, the editor would simply move the cursor to the right of the already inserted close parenthesis character.

My requirement is to my editor to keep any of these character pairs balanced. If I try to delete a line with a closing pair character that would make the pairs of such character unbalanced, the editor would delete the line content, but would leave the closing character for the pair, preventing the file from getting on an unbalanced state.

*** Rich keybindings
Any half-decent text editor these days supports an infinite plethora of shortcuts. What I believe an editor should support to be ahead of the game, is the ability to bind *any* editor action to a key, and to offer to the user some sort of guidance while one uses the editor.

For instance, if you configure your editor to search for files when you press '=SPC f f=', when you press '=SPC f=' and wait, I want the editor to display all the possible options for you to complete your key sequence.

*** Useful line numbers
I like the text editor to show me line numbers when they mater, and when they do, I like to get the most of them. This requirement is to make sure that line numbers are aware of the modal editing, so when I'm on /normal mode/ with line numbers visible, the editor should show me lines as relative numbers, and when I'm editing the file (in /insert mode/), the line numbers should be absolute.

*** Auto-saving
I want to stop saving my files. Any editor has substantial number of undo actions, and Doom even allow me to save the undo history across sessions. Because of that, I want my editor to save files I'm editing from time to time and on special events like switching to a different app, or a different buffer.

*** Persist frame position and geometry
I move my editor all around my desktop, and I resize it just as much, do I'm not particular to any specific size or position it should be, but if I turn it off, the next time I decide to open it, I expect it to be in the same place, and with the same size I defined on the last time I've open it.

*** Remote editing
I want my text editor to edit remote files seamlessly, and by remote, I mean not in the same Operating System where the editor is running. This also include containers like Docker.

I also want my text editor to allow me to start this remote editing by picking a server and a remote editor, so it can create a remote /project/ for me to explore.

** Emacs-only configurations
This section will cover some changes I like to do on the Emacs (or Doom) default behavior, and some required settings to make sure Emacs have all the information it needs to function properly.

*** Identity
It's important we let Emacs know who we are, and also, according to Doom's comments on the sample =config.el= available upon installation, some functionality uses this identification (e.g. GPG configuration, email clients, file templates and snippets).

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq user-full-name "Thiago Alves"
      user-mail-address "thiago@rapinialves.com")
#+end_src

I also like to have a variable holding the value of my email's host name:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defvar user-domain (cadr (split-string user-mail-address "@"))
  "Holds the user's personal domain. By default, this variable is
  the `user-email-address' host.")
#+end_src

*** Dashboard
Doom Emacs offers a lightweight dashboard, that serves as the landing page for Emacs.

I really like the idea of a dashboard and I like even more what Doom offers, but, the ASCII art for its logo is not something I'm affectionate with.

In order to replace the ASCII art with something more pleasant and thematic, I like to add a small picture on the dashboard:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq +doom-dashboard-banner-dir (expand-file-name "assets" doom-private-dir)
      +doom-dashboard-banner-file "doom.png"
      +doom-dashboard-banner-padding '(0 . 4))
#+end_src

I love the style of this image so much, that it is, besides my dashboard image, my Emacs icon as well. The author of this beauty is [[https://github.com/eccentric-j/doom-icon][Jay Zawrotny]], feel free to send him an accolade!

#+begin_center
[[./assets/doom.png]]
#+end_center

*** Key modifiers
Since I use a Mac as my primary computer, I need to adjust its control keys to match a good set of control keys on Emacs:

#+caption: macOS key mappings
#+name: macos-keys
| macOS Key  | Emacs Key |
|------------+-----------|
| ⌘ (cmd)    | 'super    |
| ⌃ (ctrl)   | 'control  |
| ⌥ (option) | 'meta     |

Emacs expose three variables to allow you to make these adjustments:

- ~mac-command-modifier~
- ~mac-control-modifier~
- ~mac-option-modifier~

To adjust this values according to table [[macos-keys]], set each one of them to the symbol described on the column =Emacs Key=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq mac-command-modifier 'super
      mac-control-modifier 'control
      mac-option-modifier  'meta)
#+end_src

*** Training wheels
By default, Emacs prevent you from executing certain /dangerous/ commands inadvertently. While I understand and sympathize with the need of such feature, I personally prefer to turn it off.

To change this option, set the variable ~disabled-command-function~ to ~nil~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

On Emacs, you can set variables when open files, we call those [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html][File Variables]]. There are occasions I want to execute some arbitrary code when I open a file. To do that, I would add a file variable called ~eval~, and pass my arbitrary code to it. As you can imagine, this is a dangerous features, so I have to give you the standard disclaimer:

#+begin_warning
The next configuration can lead to Emacs executing malicious code upon opening a file. By allowing Emacs to enable local ~eval~ you gain some nice ways to configure Emacs per file, on the cost of a high risk of vulnerability, so... think a little bit about how do you indiscriminately open files on your editor before enabling this one.
#+end_warning

To enable Emacs to use ~eval~ as a file variable, set the variable ~enable-local-eval~ to a non-~nil~ value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq enable-local-eval t)
#+end_src

*** Emacs source code
Emacs documentation system is fantastic! It allows you to inspect any value, binding or function on the fly, and it displays the source code for of any callable together with its documentation.

For some of the Emacs functions, such source code is a /C/ function from its core code, and by default, Emacs does not knows where to look for its own source code.

To help Emacs to find its own source code, first clone it from the Emacs [[https://git.savannah.gnu.org/git/emacs.git][repository]]:

#+caption: Commands to clone Emacs to local directory
#+begin_src shell :tangle no
mkdir -p ~/workplace/vendor/gnu
cd ~/workplace/vendor/gnu
git clone https://git.savannah.gnu.org/git/emacs.git
#+end_src

Then, set the variable ~source-directory~ to the cloned repository's path:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq source-directory (concat (getenv "HOME") "/workplace/vendor/gnu/emacs"))
#+end_src

*** Line numbers
I like to have line numbers displayed on the side of any source code I edit, but I don't like them everywhere (e.g. during prose writing), so I always make them turned off by default, and let the appropriate modes to set them on when they needed it:

To disable line numbers by default, set the variable ~display-line-numbers-type~ to ~nil~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default display-line-numbers-type nil)
#+end_src

Notice I used the function ~setq-default~ here. It tells Emacs that if a buffer uses a local version of it, it always starts with the given value.

When Emacs is showing line numbers, it do so on the window's left /gutter/. To save some screen space, Emacs only reserves only the necessary space on its gutter, to display the biggest visible line number. I believe this behavior disrupts the user experience when I scroll from line 99 to 100 and back. The visual effect is the editor screen moving right and left as I scroll.

It would be incredible inefficient to read the entire file just to check what is the biggest line number, so we can instruct Emacs do the second best thing: to only grow the gutter's size, and never shrink it.

To have such configuration, set the variable ~display-line-numbers-grow-only~ to a non-~nil~ value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default display-line-numbers-grow-only t)
#+end_src

*** Indentation
On this section, I will ask the reader to disagree on disagree, and set aside the almost religious subject of tabs versus spaces.

I prefer to always indent my files with =4= spaces with some rare exceptions for certain languages. To make Emacs use =4= spaces to indent by default, set the variable ~tab-width~ to =4=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

And to force emacs to always use spaces instead of tabs, set the ~indent-tabs-mode~ variable to ~nil~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

*** Line wrapping
Until the writing of this document, I had the opinion that /soft wrap/ was evil, and it had no place on any editor. Since then, I learned to appreciate /soft wrap/ for prose, and later in this document, you will see all the other setup around /soft wrap/ and have an idea why I was so against it.

To prevent Emacs from wrapping your text as it goes over the size of thee screen, set the variable ~truncate-lines~ to a non-~nil~ value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default truncate-lines t)
#+end_src

*** Scrolling
One of my biggest gripes over Emacs is how it handles scrolling. Besides the slowness, the entire behavior is just bonkers. For me, the logical way to deal with scrolling, is to move the screen only when we move the cursor outside of it, and the editor should only move the screen by the value of current line number minus bottom line when user is going /down/ the text.

To make Emacs not jump then necessary when cursor goes outside the screen, set the ~scroll-conservatively~ to a big number (bigger then the number of lines your display can show):

#+caption: $DOOMDIR/config.el
#+begin_src  emacs-lisp
;; (setq scroll-conservatively most-positive-fixnum)
(setq scroll-margin 3
      scroll-conservatively 1000
      scroll-up-aggressively 0.001
      scroll-down-aggressively 0.001)
#+end_src

By default, Emacs will move the cursor with the text as you scroll, but only until the edge of the screen. When the cursor reaches the edge, it will stay there as you keep scrolling. This behavior presents an anti-pattern for usability. When I decide to scroll my buffer with the mouse wheel, I'm generally looking at the screen, around the area where the cursor is. If the cursor moves up or down from its position, my eyes lose track of it, and I will assume, it stayed with its original position as I scroll. If I decide to get back writing, my expectation is to just start typing, because the cursor should be on its previous position, but if I do this, I will start typing on the wrong part of the text.

After some lookup, I believe Emacs does not support such feature yet, so I decided to go with the best alternative for usability, which is to not move the cursor from its screen position at all. This way, my eyes will keep track of its position as I scroll, and I won't have any surprises as I type.

To prevent Emacs from moving the cursor up to the edge of the screen, set the variable ~scroll-preserve-screen-position~ to a non-~nil~ value, and if you want this behavior to be the same for horizontal and vertical scroll, set it to a non-~nil~ and non-~t~ value:

#+caption: $DOOMDIR/config.el
#+begin_src  emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+end_src

To fine tune my scroll, I like to have a bit of room between my cursor and the edge of the screen when I navigate the buffer using the keyboard.

To add a margin on your cursor as it gets on the edge of the screen, set the variable ~scroll-margin~ to the number of lines you want to always keep visible:

#+caption: $DOOMDIR/config.el
#+begin_src  emacs-lisp
(setq scroll-margin 2)
#+end_src

** Modal editing
As I mentioned on section [[Modal editing]], I do consider /Modal Editing/ far superior then other methods. The main reason is the separation of states while editing a text. At some level, we all do modal editing, but the keybindings style popularized by Vim goes a step forward and /formalize/ these states.

I decided to use Doom as the base of my configuration because it has good reasonable defaults, and its author is also an ex-/Vimer/ like me, so he tailored this distribution with a Vim user in mind.

On Emacs, the package responsible to provide Vim inside Emacs is [[https://github.com/emacs-evil/evil][Evil]], and from all Vim plugins for other editors that I use, Evil is by far the best. So much that compare it with other Vim plugins is do injustice to Evil developers. More often than not, we call Evil the Vim inside Emacs.

In this section, I will go through configurations and other packages related directly to Evil, so if you don't use Evil or modal editing, feel free to skip this one.

#+begin_center
◆
#+end_center

If you're new to Vim, when you learn about the modes, on of the first /it's weird/ feelings you'll have is when you are in /Normal Mode/, then, you decide to go into /Insert Mode/, but right after that, you change your mind and press =<ESC>=... What just happened? you didn't act on anything, you didn't press any movement key, still, the cursor moved one character to the left!

Well, I have to tell you that this behavior is not a bug, is just how we should expect the change of modes to be.

I said /should/, because I disliked this behavior since I first used Vim. I never understood the rationale behind it and I always tried to fix it in my configurations. The good news is, Evil developers added an option to do just that.

To fix the moving back the cursor annoyance, set the variable ~evil-move-cursor-back~ to ~nil~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-move-cursor-back nil)
#+end_src

#+begin_center
◆
#+end_center

On the same lines of /moving back the cursor/, there is another /expected/ behavior of Vim that I don't get it, the infamous /overwriting your clipboard with the contents of a selection that you just paste on top of it/ (I couldn't find a better way to refer to this behavior).

I'm sure that, at some point, this behavior made sense for a lot of developers, but in my personal opinion, if you are pasting the clipboard on top of a selected text, is highly unlikely that you want to use the contents of such selection right after pasting something on top of it. I believe the natural behavior of developers these days, is to consider the selected text you just paste on top of it, as gone.

And just like with the previous annoyance, Evil also offers an option to change this behavior. If you want to *not* copy the content of a selection you just paste something on top of it, set the variable ~evil-kill-on-visual-paste~ to ~nil~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+end_src

#+begin_center
◆
#+end_center

Because Evil tries to stay faithful to Vim, it does not force Emacs objects into Vim's lingo. One of these examples is the visual selection. Emacs has something called /regions/ that serves, also, to the purpose of selecting text, but in reality, the Vim's visual selection and Emacs' regions, are not the same thing.

However, Evil is an Emacs package, and it also tries to integrate with existent packages and features, and it offers a configuration that makes Evil visual selection, to expand the Emacs selection region when we select something. The net effect of this, is that we can use the terms selection and region interchangeability for all practical purposes.

If you want Evil to synchronize its visual selection with the Emacs region, set the variable ~evil-visual-region-expanded~ to a non-~nil~ value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-visual-region-expanded t)
#+end_src

#+begin_center
◆
#+end_center

Vim (therefore also Evil) has this notion of a grammar to execute actions on text:

#+begin_src text :tangle no
{operation}{operator}{target object}
#+end_src

Where /operation/ is the command you're executing, operator can be /i/ (inside) or /a/ (also), and the /target object/ can be any of the targets defined Evil (e.g. /s/ for /sentence/, /p/ for /paragraph/, /[/ for /square brackets content/, etc. ).

One of these target object is /w/ for /word/ and in my experience, the meaning of /"word"/ varies according to context. Let me explain...

If you're editing a text file for blog, the meaning of /"word"/ is most likely the same meaning of the English dictionary, but if you're editing a /Lisp/ code, a word probably include more characters then the conventional /"word"/ (e.g. while /"foo"/ is a word in any context, /"foo-bar"/ is a word, probably only when you're editing a Lisp file).

A quick trick to make Evil understand the meaning of /"word"/ as I just described, is to create an alias for the function ~forward-evil-symbol~, and name it ~forward-evil-word~. This way, we override the normal function to act as if it is the ~forward-evil-symbol~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defalias #'forward-evil-word #'forward-evil-symbol)
#+end_src

** Text snippets
Snippets (also known as Live Templates on certain platforms), are tidbits of text that one can include on the editing text by typing a keyword and pressing a shortcut key (usually =TAB=) with the cursor right after the keyword.

Doom Emacs offers basic configuration for the package /[[https://github.com/joaotavora/yasnippet][Yasnippet]]/, which is the most used snippet system on Emacs.

Most snippet frameworks available across editors (including /Yasnippet/) offer the ability to edit some placeholders on the snippet so one can have a single snippet and use it on different scenarios. For instance:

Let's assume I'm a Java developer, and as such, one of the most common scenarios is for me to create a class, more or less like this:

#+begin_src java :tangle no
public class MyClassName {
    public MyClass() {
    }
}
#+end_src

I could make this text as a snippet, and I would have to replace ~MyClassName~ with whatever name I want, but I could go a step further and make my snippet something like this:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1() {
        $0
    }
}
#+end_src

Now, when I expand this snippet, I have the chance to type the name of the class right after expanding it, press =TAB= again, and get my cursor inside the public constructor.

For instance, first I type the snippet keyword (the =|= character represents the cursor, and =[]= represents a selected placeholder):

#+begin_src java :tangle no
myclass|
#+end_src

As soon as I press =TAB=, the snippet expansion happens:

#+begin_src java :tangle no
public class [|MyClassName] {
    public MyClassName() {

    }
}
#+end_src

If I type a different name for the class, the constructor will mirror that change:

#+begin_src java :tangle no
public class AwesomeClass| {
    public AwesomeClass() {

    }
}
#+end_src

And as soon as I press =TAB= again, the cursor moves to inside the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

Another functionality provided by the snippet framework, is the ability to delete a placeholder that does not make sense on the current context. As an example, lets augment our previous snippet with the ability to type arguments on the constructor:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1(${2:args}) {
        $0
    }
}
#+end_src

Now, after renaming the class, if I press =TAB=, I have the chance to type anything as an argument tot the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass([|args]) {

    }
}
#+end_src

If I press =TAB= without typing anything, I would move the cursor to inside the constructor, but would have the word =args= as a parameter definition (which, in Java, is not a valid declaration):

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass(args) {   // <-- Compile error
        |
    }
}
#+end_src

What we want to do here, is to delete the placeholder and move to the next position, and end up with the same result as before:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

By default, we can achieve this by pressing =DEL= instead of =TAB=. In general, this behavior is pretty good, except when you're typing on a MacBook laptop keyboard. MacBook keyboards don't have the key =DEL= on them, and to get a =DEL=, I have to use a combination of two keys.

For this reason, I want to make sure that the same behavior I have with =DEL=, I also have with =BACKSPACE=.

The following function, is an adaptation of the Doom's own ~+snippets/delete-forward-char-or-field~ function, but doing the reverse of it.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-snippets-delete-backward-char-or-field (&optional field)
  "Delete backward, or skip the current field if it's empty.

Prevents Yas from interfering with backspace deletion."
  (interactive)
  (let ((field (or field (and (overlayp yas--active-field-overlay)
                              (overlay-buffer yas--active-field-overlay)
                              (overlay-get yas--active-field-overlay 'yas--field)))))
    (cond ((not (yas--field-p field))
           (call-interactively #'delete-backward-char))
          ((and (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((eq (point) (marker-position (yas--field-start field))) nil)
          ((call-interactively #'delete-backward-char)))))
#+end_src

With the function defined, I can simply add it to a key bind to start using it. Notice on the following code, that I also map =⌘-RET= to allow me to end the snippet completion and accept all the default values (I'm trying to make =⌘-RET= a standard keymap that means /finish and accept/):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after yasnippet

      (:leader :prefix ("h" . "help")
       :desc "Show snippets" :n "y" #'yas-describe-tables)

      (:map yas-keymap
       :g [backspace] #'my-snippets-delete-backward-char-or-field
       :g [deletechar] #'+snippets/delete-forward-char-or-field
       :g [s-return] #'yas-exit-snippet))
#+end_src

The last configuration for snippets is to guarantee the ~yas-describe-tables~ shows up on the right side of the screen:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*YASnippet Tables\\*"
  :slot 2   :vslot -1     :side 'right   :width 104 :height 0.4
  :select t :modeline nil :autosave nil  :ttl 0     :quit t)
#+end_src

Throughout this document, you will find helpful snippets I like to define for certain features. I decided to spread the snippets across different features because I want to indicate to the reader to consider the snippet in question as an integral part of the configuration at hand.

** Inline completion
What I call inline completion, is also known as intellisense, code completion, or in the Vim world, omni completion. It's a useful tool to help the user type less and more correctly while editing source code.

Years ago, there was two main packages that provided such feature on Emacs:

- [[https://github.com/auto-complete/auto-complete][auto-complete]]
- [[https://github.com/company-mode/company-mode][company-mode]]

On the time I'm writing this part of my document, [[https://github.com/auto-complete/auto-complete][auto-complete]] is searching for a new maintainer, and I barely read any mention of it on the mainstream media.

Since I've been using [[https://github.com/company-mode/company-mode][company-mode]] for the most part of my Emacs experience, I will stick with it on my new configuration.

One of the best features I like on [[https://github.com/company-mode/company-mode][company-mode]], is its architecture design, where the author decided to modularize the package, allowing other packages to integrate with it where they actually mater. For instance, if my package offers a major mode to edit files from the /Foo/ language, I can create a =foo-company-backend= to integrate it on the Company ecosystem, or if my package provides a new cool way to display inline completions, I can create a /company frontend/ to make such integration

For the most part, Doom does a pretty good job configuring [[https://github.com/company-mode/company-mode][company-mode]] to my liking, I just need to adjust some small behaviors and keymaps.

One of the most prominent differences on my configuration is the fact that I don't like to let [[https://github.com/company-mode/company-mode][company-mode]] to show its popup automatically. It is a nice feature, but with certain backends, it can slow down the edit experience (I'm looking at you [[https://github.com/company-mode/company-mode/blob/master/company-ispell.el][company-ispell]]). For that reasons (and also because I rather the experience of [[https://github.com/ervandew/supertab][supertab]] on Vim's world), I decided to not /auto-display/ Company's popup.

In order to display the completion on my configuration, one has to press =TAB= after type couple characters of the word, or type a "=.=" character after a keyword on programming modes that support it.

Such behavior is so wildly used that Company offers a helper function (~company-indent-or-complete-common~) to help the user to handle /inserting a "=\t=" character/ versus displaying the completion. That is all and good, but unfortunately, as seen on section [[Text snippets]], I have a third function for the =TAB= key.

In order to help me handle my three cases for =TAB= I need to create small wrapper function to add the =yasnippet= check before handling completion to Company:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-company-indent-or-complete-common (arg)
  "Tab key action for current point.

This function tries to insert a tab character, trigger a snippet or complete a
word with company.

The order for this selection is:

- Org table
- Yasnippet
- Indent region
- Indent line
- Indent org-mode line
- Indent org-mode headline
- Indent org-mode item from a list
- Indent markdown-mode line
- Indent rst-mode line
- Complete with company

The action selection happens in this order and stops as soon as the first action
works."
  (interactive "P")
  (if (org-table-p)
      (orgtbl-tab arg)
    (if (or (not yas-minor-mode)
            (null (yas-expand)))
        (cond ((use-region-p) (indent-region (region-beginning) (region-end)))
              (t (let ((old-point (point))
                       (old-tick (buffer-chars-modified-tick))
                       (tab-always-indent t))
                   (indent-for-tab-command arg)
                   (when (and (eq old-point (point))
                              (eq old-tick (buffer-chars-modified-tick)))
                     (unless (pcase major-mode
                               ('org-mode (or (org-indent-line)
                                              (org-cycle-level)
                                              (org-cycle-item-indentation)))
                               ('markdown-mode (markdown-indent-line))
                               ('rst-mode (rst-indent-line nil))
                               (_ nil))
                       (company-complete-common))))))
      (company-abort))))
#+end_src

This function incorporates the source code of ~company-indent-or-complete-common~ to allow me to handle special cases like in Org mode when I want to indent a list item or headline. It first tries to expand the previous word on a snippet. If it can't, it falls back to the altered Company function, where it also tries to do an Org indent, or a Markdown indent, or a reStructuredText before settling on ~company-complete-common~.

But what if I'm already displaying the Company popup, but I want to expand what I just typed into a snippet? The previous function can't help us, because it does not handle navigating the completion options with =TAB=. For such behavior, I need another function that I should run instead of the previous one if I have Company's popup opened:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-completion-yasnippet-or-completion ()
  "Tab key action when company popup is visible.

This function tries to expand a snippet, complete a common prefix on a company
completion, or move the company selction to the next item."
  (interactive)
  (if (or (not yas-minor-mode)
          (null (yas-expand)))
      (company-complete-common-or-cycle)
    (company-abort)))
#+end_src

Notice that the only difference between ~my-company-indent-or-complete-common~ and ~my-completion-yasnippet-or-completion~ is that I call ~company-indent-or-complete-common~ on the former, and ~company-complete-common-or-cycle~ on the later.

Another deviation from the standard that I like, is how the =RET= should work with Company.

For me, there are two scenarios that can happen if one presses =RET= while the Company popup is visible:

1. The user meant to insert a "=\n=" character on the document;
2. The user intended to select the selected completion option;

The way to distinguish between these two scenarios, is to check if Company already have a selection stored at ~company-selection~. If it does have, the =RET= should represent a ~company-complete-selection~, otherwise, the =RET= should close the Company popup, and insert a "=\n=" character on the document. I created the next function to manage these behavior:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-completion-complete-selection-or-return ()
  "Return key action when company popup is visible.

This function will select current company item if user already selected one, or
insert a new line character."
  (interactive)
  (if company-selection
      (company-complete-selection)
    (company-abort)
    (execute-kbd-macro (read-kbd-macro "<return>"))))
#+end_src

Notice also, that I didn't use ~insert~ when a =RET= means to /add a new line/. This decision is to allow Emacs to trigger any function or hook tied to the =RET= key.

With all auxiliary functions created, I just need to setup Company according to my needs:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay nil)
  (setq tab-always-indent 'complete)
  (setq company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (setq company-box-doc-enable nil)
  (setq company-frontends (delq 'company-pseudo-tooltip-frontend company-frontends))

  (add-hook 'evil-normal-state-entry-hook #'company-abort))
#+end_src

One configuration that worth mention why I choose it is to set ~company-box-doc-enable~ to =nil=. I did this, not because I don't like the documentation as another child frame, is the fact that if I do show it, I can't move my popup completion without aborting Company.

Last, I need to setup the proper keymaps for the package:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after company
      (:map global-map
       :i [tab] #'my-company-indent-or-complete-common)
      (:map company-active-map
       :g [tab] #'my-completion-yasnippet-or-completion
       :g [backtab] #'company-select-previous
       :g [down] #'company-select-next
       :g [up] #'company-select-previous
       :g [return] #'my-completion-complete-selection-or-return
       :g "C-S-j" #'company-next-page
       :g "C-S-k" #'company-previous-page
       :g "C-/" #'company-show-doc-buffer))
#+end_src

** Automatic indentation
I appreciate the fact that majority of editor these days can keep the indentation of the previous line, and some of them, are even capable of adding indentation where is necessary. Although this is a good start, I want my editor to do more. When I add braces around a code, or when I make a one-line statement, a multi-line one, I want the editor to reformat my file to properly intent it.

Emacs offers a mode called ~electric-indent-mode~ where the ultimate goal, is to achieve exactly what I described, but unfortunately, the current state of the mode is falling short of it.

The solution I found, is an external package called ~aggressive-indent~ that re-indent the entire file on every change.

It is a bit too aggressive, but so far is working just fine for me, so let's add it to our packages:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! aggressive-indent)
#+end_src

A point to note is where to use this package. I need it on ~prog-mode~, but due to some particularities of certain languages (did someone said Python here?), I need to specify the set of languages I want to support aggressive indent. The reader can check the list of supported language on the following code snippet:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! aggressive-indent
  :hook ((emacs-lisp-mode
          c-mode
          cpp-mode
          rust-mode
          go-mode
          java-mode
          kotlin-mode
          shell-mode
          javascript-mode
          typescript-mode) . aggressive-indent-mode))
#+end_src

The reason to not include Python on this list, is the fact that Python uses indentation as block delimiter, and the package does not know how where a block ends and a new starts, causing re-indentation to pretty much break the code.

** Smart backspace
As part of my day job, I had to do a lot of Android development, and inevitably I used [[https://www.jetbrains.com/][JetBrains]]
IDE [[https://www.jetbrains.com/idea/][IntelliJ IDEA]]. I bring this up not to chastise who uses or to complain about it. In face, IntelliJ the best IDE for Java and Kotlin out there. It has some features that are so good, that I want to implement on any text editor I use. One of these features is what I call /Smart Backspace/.

On both, Doom and IntelliJ, when you type an open pair, the editor completes with the closing one:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

Also on both, when you press =<ENTER>=, the editor position the cursor on a newly inserted line, on using the correct indentation, and it also inserts a '=\n=' character after cursor. The result of these actions would be like this:

#+begin_src kotlin :tangle no
fun foo() {
    |
}
#+end_src

The difference between both editors happens when you press =<BACKSPACE>= at this point. While in Doom, this operation would result in:

#+begin_src kotlin :tangle no
fun foo() {
|
}
#+end_src

On IntelliJ, it results in:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

But what happened here?

IntelliJ was able to figure out that, since I was on the indent column of the line *and* I haven't typed anything after the auto-pair, when I pressed =<BACKSPACE>=, my intention was to get back to the state I was before pressing =<ENTER>=, therefore the name I gave to this feature: /Smart backspace/.

To achieve the same result with Doom, we have to add a function advice to delete advice Doom adds to Emacs (the ~+default--delete-backward-char-a~ advice is what is responsible to balance the blank characters you enter after a pair completion).

Our advice function checks if our cursor is position on the expected position to revert the =<ENTER>= pressed between the two pairs. If it is, we remove all the characters before the cursor on the current line. This will put the cursor on a position that Doom's advice function can remove the two new line characters around the cursor, putting the buffer on the same state we were before we pressed =<ENTER>=:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-super-backward-delete-a (&rest _)
  "Special function to super-delete things.

If the line content before cursor contains only blank characters, this function
will delete all the blank characters, and then, join with the previous line. I
there is any non-blank character before cursor, this function will delete the
entire line, but keep the correct indentation on it."
  :before '+default--delete-backward-char-a
  (let* ((line-pos (- (point) (point-at-bol)))
         (prev-indent (save-excursion
                        (forward-line -1)
                        (current-indentation)))
         (prev-line-bol (point-at-bol 0))
         (next-line-eol (point-at-eol 2))
         (smart-bs-p (or (save-excursion
                           (and (re-search-backward "{[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*}" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "\\[[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*\\]" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "([ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*)" next-line-eol t))))))
    (when (and smart-bs-p
               (<= line-pos (+ prev-indent standard-indent)))
      (delete-char (- line-pos)))))
#+end_src

Adding this advice as an /autoload/ function on our configuration is all we need to get the functionality working. When Doom loads the =smartparens= on the default module, it replaces the Emacs ~delete-backward-char~ function with its ~+default--delete-backward-char-a~ advice, which will load our function, which, in turn, installs itself as a =:before= advice on Doom's function.

** Balanced pairs
In most editors (as far as editors go, I only saw Emacs allowing balanced pairs), there is no balanced pair protection. If you remove a line where a closing character is, without removing its open pair, your buffer becomes unbalanced.

Emacs has some packages that help you keep the balance on pair characters, even if you try to remove a line containing just one of the pairs.

Among the packages I checked, the two top two contenders for me are =lispville= and =smartparens= + (=evil-cleverparens= or =evil-smartparens=).

From the two, =lispville= seams to be the most maintained, but it depends on =lispy= and even though you can use it just for the balance protection, it requires much more code and effort to do it right, so my choice is =smartparens= + =evil-cleverparens=. I tried =evil-smartparens= before, and it is not as polished as =evil-cleverparens=.

To install them, make sure =smartparens= is enable in your =init.el=:

#+caption: $DOOMDIR/init.el
#+begin_src emacs-lisp :tangle no
  :config
  (default
      +bindings
      +smartparens)
#+end_src

And =evil-cleverparens= is on the =packages.el= file as well:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-cleverparens)
#+end_src

These changes will make Doom download them into its local cache when you run =doom sync=.

Before I configure these packages, I would like to explain why I turn on balance protection only on Emacs modes deriving from =prog-mode=.

The simplest explanation is that you don't really need pair balance protection in any other place then you coding buffers. I did some informal experiments on this area, and found that pair protection turned on when you write prose is magnitudes more annoying then useful, so I will stick with protection only in =prog-mode=.

To make Emacs turn =smartparens= and related packages correctly, make sure that you turn on =evil-cleverparens-mode= on the =smartparens-enabled-hook=, and only enable the strict mode when editing a =prog-mode= buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! smartparens
  :init (add-hook 'smartparens-strict-mode-hook #'evil-cleverparens-mode)
  :hook ((prog-mode . smartparens-strict-mode)))
#+end_src

Doom will turn on =smartparens= appropriately, so we don't need to hook anything else to get this feature working, but there is one more configuration that I like to have on, all the time. It is the ability of Emacs to highlight the /other pair/ when the cursor is on top of a character pair.

To do so, enable the =show-smartparens-global-mode= after enabling =smartparens=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! smartparens
  (show-smartparens-global-mode 1))
#+end_src

** Rich keybindings
The good thing about this feature is that Emacs already covers almost all of my [[Rich keybindings][requirements]] for free, and doom ships with a package that covers the rest of it (=which-key=). What I need to do here, is to tweak =which-key= to /look/ and /feel/ like I want it.

One aspect of which key that bothered me is not so much a =which-key= thing, and more an Emacs thing in general. This aspect is how popup windows show and hide. When Emacs shows one on the bottom of the screen, it shifts the window I'm working on upwards, and although this came to be the expected behavior, it disrupt my flow, specially if the time I take to finish a shortcut sequence is couple milliseconds more then the =which-key= timeout.

To remediate this situation, I found this package called =which-key-posframe= that display the shortcut hints on a child frame. With a configuration or two, I believe this package can deliver what I want.

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! which-key-posframe)
#+end_src

The main adjustments I want to do, is to make sure the child frame /width/ is big enough to fit the biggest description I can have.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! which-key-posframe
  :hook (which-key-mode . which-key-posframe-mode)
  :custom
  (which-key-posframe-poshandler 'my-posframe-poshandler-frame-right-middle)
  (which-key-posframe-parameters '((min-width . 44))))
#+end_src

And respect the border color for popups:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  `(which-key-posframe-border :background "#000000")
  `(which-key-posframe :background "#21242b"))
#+end_src

I need also to set the ~which-key-posframe-poshandler~ variable, to allow a special behavior regarding positioning the child frame on the screen.

This special behavior is simply to most of the times, show the shortcut hints on the right side of the frame, but if I invoke an Embark action, I want the shortcut hints child frame to show up right besides the cursor point.

To achieve this behavior, I'll define a =nil= placeholder variable that I can set to =t= when invoking Embark.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defvar my-which-key-on-embark nil)
#+end_src

Which such variable created, I can define my function to place the frame where I want it:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-posframe-poshandler-frame-right-middle (info)
  "Posframe's position handler.

Get a position which let posframe stay vertically centralized onto current
frame's right site. Checkk the docstring of `posframe-show' for more information
about the INFO structure."
  (if my-which-key-on-embark
      (posframe-poshandler-point-bottom-left-corner info)
    (let* ((frame-width (plist-get info :parent-frame-width))
           (frame-height (plist-get info :parent-frame-height))
           (posframe-width (plist-get info :posframe-width))
           (posframe-height (plist-get info :posframe-height)))
      (cons (- frame-width posframe-width (line-pixel-height))
            (/ (- frame-height posframe-height) 2)))))
#+end_src

In order to connect =embark= to =which-key=, I need to advice the function I defined to invoke =which-key= when I invoke =embark=:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-embark-which-key-action-wrapper (orig-fun &rest args)
  "Wrap ORIGIN-FUN on a let bind to indicate this is an Embark call.

It passes ARGS to ORIGIN-FUN without altering them. "
  :around 'my-embark-which-key-action-indicator
  (let ((my-which-key-on-embark t))
    (apply orig-fun args)))
#+end_src

With the =which-key-posframe= configured, I just need to do some minor adjustments on the =which-key= package to make it display the hints on a single column with a single description occupying up to 40 characters of such column:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! which-key
  (setq which-key-allow-multiple-replacements t)
  (setq which-key-min-display-lines 10)
  (setq which-key-max-display-columns 1)
  (setq which-key-add-column-padding 2)
  (setq which-key-max-description-length 40))
#+end_src

** Useful line numbers
A long time ago, I read on some Vim mailing list, an opinion on how line numbers should behave on different editing modes (if you know who is the original author of such idea, please let me know so I can give credit where credit is due). Since on normal mode is pretty useful to know the line count from the cursor until some target text, it makes more sense to have the =relative number= shown on the gutter, but when I'm editing the buffer, is nice to have a sense of size by looking to the line numbers.

So, I can describe this behavior as follows:

- When on normal mode, show relative line numbers;
- When on insert mode, show absolute line numbers;

To achieve this, I need a function that turns the /absolute/ line number when line numbers are visible:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-absolute-h ()
  "If line numbers are visible, set the current line number type to `absolute.'"
  (if display-line-numbers
      (setq display-line-numbers t)))
#+end_src

And another function to put the line numbers on /relative mode/ (but again, only if line numbers are visible):

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-visual-h ()
  "If line numbers are visible, set the current line number type to `visual'"
  (if display-line-numbers
      (setq display-line-numbers 'visual)))
#+end_src

With those functions created, after loading Evil, I can hook them to a mode switch:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook! '(evil-emacs-state-entry-hook
               evil-insert-state-entry-hook) 'my-line-number-absolute-h)
  (add-hook! '(evil-emacs-state-exit-hook
               evil-insert-state-exit-hook) 'my-line-number-visual-h))
#+end_src

To finalize, I want to make line numbers visible on any programming mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (setq-hook! 'prog-mode-hook display-line-numbers-type 'visual))
#+end_src

** Auto-Saving
First of all, since I'm going to save my work constantly, I don't want Emacs to ask me if it should really exit, or if it should kill outstanding processes while doing it. For me, if I'm telling Emacs to quit, I want it to do it, regardless its state, but I don't want to lose any content of my current work. So, the first thing I'm going to do, is to disable questions when I'm quitting Emacs:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)
#+end_src

Emacs allows you to define some /advices/ to any function you want. This allows you to hook some code when the user, or the system calls such functions. On the case of aggressive auto-save, I want Emacs to save any content when I try to close the buffer associated with the content, of if I'm trying to quit Emacs. To do so, I'll create an /autoload/ advice to perform such work:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-save-all-buffers-a (&rest _)
  "Advice to run `save-some-buffers' before a function.

This is a part of the full auto-save feature."
  :before (list #'save-buffers-kill-emacs #'my-tabs-close-buffer-tab)
  (save-some-buffers t t))
#+end_src

And to wrap up this configuration, I enable the auto-save mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(auto-save-visited-mode 1)
#+end_src

Call the same advice as a normal function when Emacs executes the auto-save hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! 'auto-save-hook #'my-save-all-buffers-a)
#+end_src

And add the advice function to the ~after-focus-change-function~ as well, just to make sure Emacs save any outstanding buffer as soon as possible if it loses focus:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-function :after after-focus-change-function #'my-save-all-buffers-a)
#+end_src

This aggressive auto-save will work as expected, but it will crate a side effect with my literate configuration. Since Doom tangles the Org file every time we save it, the aggressive auto-save will make this tangle happen more often than we want.

Doom documentation offers a partial solution to this problem asking us to remove the auto-tangle function from the save hook, so let's do it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'org-mode-hook #'+literate-enable-recompile-h)
#+end_src

Another core behavior that does not play well with my aggressive auto-save configuration is how Doom configures =ws-butler=. While I understand the rational behind the choice of always remove blank spaces regardless the cursor position.

To adjust that, let's make =ws-butler= behave how I expect it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! ws-butler
  (setq ws-butler-keep-whitespace-before-point t))
#+end_src

** Persist frame position and geometry
Before I start tackling my own requirement, let's make Emacs /remember/ its window size and position between launches.

First, I like to define an auto loaded function to hook into the emacs kill process to save frame dimensions. The reason to get an auto load function, is to allow Emacs to *not* load it until it really needs it, which would be when I'm quitting Emacs.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-save-frame-dimensions-h ()
  "Caches the current frame dimensions and position."
  (if-let ((main-frame (car-safe (visible-frame-list))))
      (doom-store-put 'last-frame-size
                      (list (frame-position main-frame)
                            (frame-width main-frame)
                            (frame-height main-frame)
                            (frame-parameter main-frame 'fullscreen)))))
#+end_src

Then, I like to have the analog function to call when we create a frame:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-restore-frame-dimensions-h ()
  "Restore frame dimensions and position from `my-save-frame-dimensions-h'."
  (if-let (dims (doom-store-get 'last-frame-size "default"))
      (cl-destructuring-bind ((left . top) width height fullscreen) dims
        (setq initial-frame-alist
              (append initial-frame-alist
                      `((left . ,left)
                        (top . ,top)
                        (width . ,width)
                        (height . ,height)
                        (fullscreen . ,fullscreen)))))
    (add-to-list 'default-frame-alist '(height . 40))
    (add-to-list 'default-frame-alist '(width . 140))))
#+end_src

With the function defined, I just need to connect them to the correct hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-emacs-hook #'my-save-frame-dimensions-h)
(my-restore-frame-dimensions-h)
#+end_src

** TODO Remote editing

* Personal preferences
This section will show the reader, some of the small changes I decided to implement on Doom related to Evil, my personal keybindings, my choice of appearance, and other personal configurations. All in all, is pretty safe to skip this section if you intend to implement your own customization.

** Evil
For most of it, Doom integration of Evil is pretty amazing, I found just one package I don't use (or don't want to use at all), two configurations that I want to do some adjustments, and three packages missing.

The package I don't use is =evil-escape=, and its purpose, is to allow one to type =j k= fast enough on insert mode to force moving from insert mode to normal mode.

If you're used to this feature, good for you, but I was never able to adjust my muscle memory to it, so I rather disable it on =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

The first Evil configuration I want to adjust to my liking is on =evil-goggles=. I understand Henrik (Doom's creator) has a good rational on why he setup =evil-goggles= the way it is, but I like the original design where *all* changes get the highlight treatment.

Also, I use =evil-cleverparens=, and its editing operations are not configured on =evil-goggles=, so, in order to make it work for me I have to do two things:

1. Re-enable the change feedback disabled by default on Doom;
2. Add all =evil-cleverparens= commands to the ~evil-goggles--commands~ to allow =evil-goggles= to handle changes from those commands as well.

I can perform those changes using ~use-package~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-goggles
  :hook (doom-first-input . evil-goggles-mode)
  :config
  (setq evil-goggles-duration 0.15
        evil-goggles-enable-delete t
        evil-goggles-enable-change t)

  (pushnew! evil-goggles--commands
            '(evil-cp-delete
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-line
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--delete-line-advice)
            '(evil-cp-delete-sexp
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-enclosing
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-yank
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-line
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-sexp
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-enclosing
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-change
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-line
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-sexp
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-enclosing
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-paste-after
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)
            '(evil-cp-copy-paste-form
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)))
#+end_src

After this I can sneak a quick modification to allow =evil-goggles= to use the same faces used on =diff=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil-goggles
  (evil-goggles-use-diff-refine-faces))
#+end_src

The second configuration is regarding centralizing the cursor after search jumps. I find myself pretty uncomfortable after I press =n= following a search term, and I figured it out that what makes me uncomfortable is the fact the cursor is on the bottom of the screen, and I have almost no visibility of the text after it.

To fix this, I will add an advice after the Evil search function used to perform those jumps, to recenter the cursor on the window:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-center-after-jump-a (&rest _)
  :after 'evil-ex-search
  (evil-scroll-line-to-center nil))
#+end_src

And to make this behavior more consistent throughout the editor, I will add the same function used to advise ~'evil-ex-search~ as a hook to the ~evil-jumps-post-jump-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook 'evil-jumps-post-jump-hook #'my-center-after-jump-a))
#+end_src

And finally, for the packages I'm missing, they are:

- =evil-matchit=
- =plus-minus=
- =evil-string-inflection=

*** Evil-MatchIt
In all fairness, =matchit= (the one originally from Vim) is also disabled by default, but it provides such useful feature that I can't understand why it is not part of the standard Vim/Evil.

To the reader not familiar with this plugin, let me give a brief overview of it. You probably know that pressing the key =%= on a pair character (e.g. =(=, =)=, =[=, =]=, etc.), makes the cursor jump to the other pair.

The =matchit= plugin, extends this functionality to other types of pairs, like XML/HTML tags, language control flows like =if=, =else=, and =endif=, and others. So, as I said, a pretty useful plugin!

Since =evil-matchit= is not distributed with Doom, I need to bring its package in:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-matchit)
#+end_src

Then, need to make sure to enable the plugin itself. In order to not slow the Emacs startup, I will enable it after I load the first file into a buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-matchit
  :hook (doom-first-file . global-evil-matchit-mode)
  :init
  (setq evilmi-quote-chars (string-to-list "'\"/")))
#+end_src

*** Plus-Minus
=plus-minus= is a package that provides the functionality to increase or decrease a number value at point. On Vim, the key bindings for these actions are =C-a= and =C-x= respectively.

I spend too much time thinking that I should preserve the =C-x= keybinding for Emacs' sake, and I learn to use a command or two that uses it, but the reality is that I don't really need it, so I will give it a try on rebinding this key to its original Vim purpose, but instead of using =evil-numbers= (which Doom provides as a core package), I'll try a brand new package called =plus-minus=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-numbers :disable t)

(package! plus-minus
  :recipe (:host github
           :repo "peterwu/plus-minus"))
#+end_src

Since this package provides the correct ~autoloads~ on it, I can simply configure it to get deferred until I actually need it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! plus-minus :defer t)
#+end_src

Before defining the keybindings for this I would like to have an extra behavior when I try to increase or decrease a number at point. I would like to rotate the text at point with the same keybinding if the /thing at point/ is not a number.

Doom ships with the =rotate-text= package by default, but I need couple helper functions to define which package should handle the key press:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-inc-or-rotate-at-point (arg)
  "Try to rotate or increase the text at point.

If the thing under cursor is not rotated, tries to increase the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward+) (+/-:forward+))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward+) (+/-:forward+))))))
#+end_src

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-dec-or-rotate-at-point (arg)
  "Try to rotate or decrease the text at point.

If the thing under cursor is not rotated, tries to decrease the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))))))
#+end_src

And I also like to define some extra words for rotation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! rotate-text
  (add-to-list 'rotate-text-words '("yes" "no"))
  (add-to-list 'rotate-text-words '("allow" "deny"))
  (add-to-list 'rotate-text-words '("allowed" "denyed")))
#+end_src

With all in place, we just need to define the keybindings:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :n "C-a" #'my-inc-or-rotate-at-point
  :n "C-x" #'my-dec-or-rotate-at-point
  (:prefix "g"
    :desc "Inc sequence" :v "C-a" #'+/-:block+
    :desc "Dec sequence" :v "C-x" #'+/-:block-))
#+end_src

*** Evil-String-Inflection
I've been on situations where I realized that I used /camelCase/ for all my variables, where the standard coding style of the language, request to use /snake_case/ style. There are packages available, that allow you to cycle through all case styles on a given word.

I found the =evil-string-inflection= to have one of the best integration with Evil, so I will stick with it for a while to evaluate things:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-string-inflection)
#+end_src

As with the =matchit= package, I'll defer its loading until we need it, but different from =matchit=, I have to defer it using an alternative approach. I will make the package load on the first invocation of the command ~evil-operator-string-inflection~, then, on the =:init= section, I will setup the proper keymap using the Doom ~map!~ function:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-string-inflection
  :commands (evil-operator-string-inflection)
  :init
  (map! :prefix "g"
        :desc "String inflection" :o "~" #'evil-operator-string-inflection))
#+end_src

** Keybindings
Since I decided to write this configuration, I also decided to try to use the standard Doom key bindings as much as possible, and for the most part of it, I'm not having as much problem as I expected. There are three main areas where I still like to define my own bindings.

*** Window navigation
A while ago, I configured Vim to move the cursor from one window to another using the standard movements keys (=h=, =j=, =k=, and =l=) while keeping =Ctrl= pressed. I got so used to these shortcuts, that I can't live without it anymore.

The good news is that, on most cases, there is no conflict between features I use and these shortcuts, and on the cases that a conflict exists, there are reasonable options to workaround these limitations.

The first step to achieve a global is to clean the target keys from any keymap that might bind them to a command:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after outline
  (:map outline-mode-map
   :gn "C-h" nil
   :gn "C-j" nil
   :gn "C-k" nil
   :gn "C-l" nil)))
#+end_src

After that, I can bind these keys to the target window movements to the proper window commands:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :gn "C-h" #'evil-window-left
  :gn "C-j" #'evil-window-down
  :gn "C-k" #'evil-window-up
  :gn "C-l" #'evil-window-right)
#+end_src

Some other modes don't play nice with this particular key bindings I choose, and I have to adjust them accordingly. This is the case of the =Info-mode=, where =C-j= and =C-k= are the keys to navigate forward and backwards on nodes. The solution for me is to bind those commands to other keys, and configure the proper window navigation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after info
      :map Info-mode-map
      :gn "s-k" #'Info-backward-node
      :gn "s-j" #'Info-forward-node
      :gn "C-k" #'evil-window-up
      :gn "C-j" #'evil-window-down)
#+end_src

*** Vim defaults
Here I need to make yet another disclaimer to the reader: I know what I'm about to write is a pet peeve, and most likely most Doom users won't even understand this, but...

On Doom, there are these keymaps bound to =<leader> w ...=, that should match Vim's =<C-w> <C-...>=. Since the /leader shortcuts/ are more ergonomic for me, I got used to them quickly. The problem I have, is the difference between =<C-w> <C-o>= and =<leader> w o=!

To not lose a Doom-only keymap, instead of simply rebinding =<leader> w o= to the /correct/ command, I'll /move/ ~doom/window-enlargen~ to a different keymap (=<leader> w z= to represent /zoom window/), and assign the /correct/ command to the /correct/ keymap:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("w" . "window")
      :desc "Enlarge window"         :n "z" #'doom/window-enlargen
      :desc "Select window"          :n "o" #'delete-other-windows)
#+end_src

*** Personal shortcuts
Key bindings in this section are purely personal choice. Feel free to give them a try if you want, but if you're used to Doom Emacs already, my suggestion is to skip this section.

#+begin_center
◆
#+end_center

The first keymap group I like to add custom shortcuts is the multiple cursors. When I first heard about multiple cursors, was on a demo of the [[https://macromates.com/][TextMate]] editor. I got so impressed by it that this feature was one of the first things I would search on an editor. Fast forwarding to January 2008, I was watching yet another demo of a brand new editor, when the person showing off the features, demonstrated the multiple cursors. This editor was [[https://www.sublimetext.com][Sublime Text]], and I couldn't resist the chance to give it a try. For reasons of the brain (at least my brain), the shortcuts defined to manipulate multiple cursors got engraved in my memory, and recently, I decide to stop fighting against it and embrace! So these are the shortcuts (which might be different from the current shortcuts in Sublime) that I got /used to/:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 :gn "s-d" #'evil-mc-make-and-goto-next-match
 :gn "s-u" #'evil-mc-skip-and-goto-prev-cursor
 :gn "s-n" #'evil-mc-skip-and-goto-next-match
 :gn "s-g" #'evil-mc-make-all-cursors
 :gn "C-M-k" #'evil-mc-make-cursor-move-prev-line
 :gn "C-M-j" #'evil-mc-make-cursor-move-next-line)
#+end_src

#+begin_center
◆
#+end_center

Another /nice to have/ binding I got used to, is to move blocks of text up and down, using =j= and =k=, plus the =Meta= (a.k.a. =Alt=, =option=, or  =⌥=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :nvi "M-j" #'drag-stuff-down
      :nvi "M-k" #'drag-stuff-up)
#+end_src

#+begin_center
◆
#+end_center

Something that I really like but usually forget to use is the ability to insert a new line while on /insert mode,/ above or bellow the current line, regardless where the cursor is. To use it, I would simply press =<ENTER>= with =<SUPER>= (a.k.a. =cmd= or =⌘=) to insert a line bellow, or =<ENTER>= plus =<SHIFT>= and =<SUPER>= for a line above:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :i [s-return]   #'+default/newline-below
      :i [s-S-return] #'+default/newline-above
      (:when IS-MAC
         :gn "s-RET"        nil
         :gn [s-return]     nil
         :gn "S-s-RET"      nil
         :gn [S-s-return]   nil))
#+end_src

#+begin_center
◆
#+end_center

Doom Emacs, offer a shortcut to bring back the last dismissed popup, which is what I want to do on the majority of the cases. But some times, I want to bring back a specific popup buffer to the front, and I like to have a dedicated prefix key to handle this scenario.

For now, I set a shortcut for the =*Messages*=, and the =*Backtrace*= buffers, but more popup buffer might get added here in the future:

#+caption:config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("v" . "view")
      :desc "View Messages" :n "m" #'(lambda ()
                                       (interactive)
                                       (pop-to-buffer "*Messages*")
                                        (goto-char (point-max)))
      :desc "View Backtrace" :n "e" #'(lambda ()
                                        (interactive)
                                        (pop-to-buffer "*Backtrace*")))
#+end_src

As you can see, I also like to /scroll to the bottom/ of the buffer when opening messages. The rational behind it is the fact that if I want to quick loo into the =*Messages*= buffer, is most likely to check the latest messages there.

Also for the =*Messages*= buffer, I like to be able to press =q= to quit as well. Unfortunately this is not defined by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map messages-buffer-mode-map
      :n "q" #'delete-window)
#+end_src

#+begin_center
◆
#+end_center

One binding I feel is missing on Doom, is the ability to evaluate any sexp on *any* mode, like a /global/ ~eval-last-sexp~. Gladly, it's easy enough to create my own:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :prefix "g"
      :desc "Eval last sexp" :n ")" #'eval-last-sexp)
#+end_src

#+begin_center
◆
#+end_center

I don't remember when this shortcut entered my life, but some time ago I got used to use =s-RET= to /confirm operations/ like sending emails and messages. In order to try to replicate this behavior I will start setting it to the ~with-editor-mode-map~ together with the analog cancel operation with =s-ESC= shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map with-editor-mode-map
      :in [s-return] #'with-editor-finish
      :in [s-escape] #'with-editor-cancel)
#+end_src

#+begin_center
◆
#+end_center

Doom ships with the /Rainbow Mode/ package, which is a package that colorizes strings that represent colors. Usually there is no need to enable this mode globally because the colorization might get in the way of legibility, but on the cases where it is useful (e.g. editing CSS or Android XML files), it is *really* useful.

Because of this, I want to set this mode as a toggable shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("t" . "toggle")
      :desc "Rainbow mode" :mvn "R" #'rainbow-mode)
#+end_src

** Appearances
As far as I understand, there is a share of Emacs users that value Emacs functionalities over its looks, and I would like to write something targeted for those users.

You are awesome! I can't imagine how liberating it would feel if my brain did not obsessed about my editor's appearance, so, stay strong folks! The breakthroughs on technology happens more often by the desired of people like you then people like me.

With that out of the way, I need to explain to the reader my personal position on this subject. As a person with [[https://en.wikipedia.org/wiki/Attention_deficit_hyperactivity_disorder][ADHD]] and [[https://en.wikipedia.org/wiki/Obsessive%E2%80%93compulsive_disorder][OCD]].

Looks mater. There is not much else to say, but if you need a bit more let me say this: When your brain is constantly searching for dopamine, and is incapable to retain it for much longer, every tinny rewarding counts towards the goal to keep my focus on one subject. If my work environment is pleasing to look, there is a lower chance my brain gets distracted by the scene outside the window. If I open my editor and get the feeling of /"oh yeah"/, than my brain will look forward to use the same tool again, or as I saw on this [[https://twitter.com/ADHDelaide/status/1326412306079682560][tweet]] a while ago, and reproduce it here for you:

#+begin_quote
❝ Having *ADHD* is basically finding new ways to trick your brain into doing the stuff you want it to do, until you die. ❞
─ *@ADHDelaide*
#+end_quote

Nevertheless, keep in mind that taste, is a personal thing. What I consider to be beautiful, might look horrendous to the reader, and that is OK.

So, if you're happy with the look and feel of your editor, feel free to skip this entire section.

*** Frame

The Emacs frame is the container for my small world, and although I intend to do most of my things within Emacs, I still want it to look like it belongs to its environment (macOS in my case), and there are couple things I like to change to make it more macOS.

The first one is to remove the text from the title bar. On macOS, the application name is present on the system menu, so there is no reason to keep any text on the title bar:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq frame-title-format nil
      ns-use-proxy-icon nil)
#+end_src

And the second one, is to make the title bar to have the same color as the background of my selected theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

*** Editor

The first thing to do to help with my editor appearance, is to store the current line height in a variable. This way, other adjustments can use this value without worrying about different font sizes:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defvar my-line-pixel-height (line-pixel-height)
  "Line height in pixels.

Used to avoid getting the wrong line height when `text-scale-mode' is active.")
#+end_src

One editor visual I like to have while I'm coding, is the ~fill-column-indicator~. Unfortunately I discovered that on macOS, the default ~fill-column-indicator~ face, can't render Unicode characters properly. The workaround here is to make this particular face to use a font that can render them:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-face-attribute 'fill-column-indicator nil
                    :font "Arial Unicode MS"
                    :height 140
                    :foreground (doom-color 'base3 256))
#+end_src

Using /Arial Unicode MS/ allow me to use the "=┊=" character to decorate my ~prog-mode~ buffers. After setting this up, I need to adjust the ~fill-column~ value to the column I want (while is usually 100),  and make the column indicator use the correct Unicode character (which is =0x9482=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default fill-column 100
              display-fill-column-indicator-column 100
              display-fill-column-indicator-character 9482)
#+end_src

After this configuration I want to make sure the column indicator is off by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(global-hl-line-mode -1)
#+end_src

And enabled on all ~prog-mode~ buffers:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
#+end_src

#+begin_center
◆
#+end_center

As with column indicator, there is another visual that I consider crucial for programming, but a bit annoying when writing prose: The current line highlight.

I can't imagine coding without it, but when I'm writing, it becomes more a distraction then an aid.

On Doom, to make sure current line highlight gets disabled, you need to remove its global mode from the ~doom-first-buffer-hook~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Then, I can add the mode to all ~prog-mode~ buffers with another hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+end_src

#+begin_center
◆
#+end_center

Another extra for the editor visuals is rendering the character =^L=, which represents a page break (more precisely, the /form feed/ character).

The page break character is consider a /space/ or /empty/ character, which allows one to add it on a coding file without breaking the build for such file.

There are a couple packages that achieve this goal but I set on the [[https://github.com/purcell/page-break-lines][=page-break-lines=]] from [[https://github.com/purcell][Steve Purcell]] because he chose to implement this feature using glyph composition instead of /font-lock/:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines)
#+end_src

There is just one configuration I prefer to change over the defaults, which is the size of thee horizontal line. I like the horizontal like to stop at the ~fill-column~ column, which gives this nice /box feeling/ to the code.

Besides this change, I only enable the mode on =prog-mode= buffers, and I like to define a shortcut key to jump to the next or previous page break:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! page-break-lines
  :hook ((prog-mode . page-break-lines-mode))
  :init
  (setq page-break-lines-max-width fill-column)

  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

#+begin_center
◆
#+end_center

Since the time when widescreen monitors became the standard, when it comes to split windows in two, I prefer horizontal splits (one window aside of the other). In order to tell Emacs that I prefer horizontal splits, I have to set the width split threshold to a small number to add weight on Emacs' decision of which orientation to split:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq split-width-threshold 40)
#+end_src

*** Theme
I believe this section to be the most volatile section on this text. Since I got interested on cool old esoteric editors, I'm on an endless search for the Holy Grail of themes. So far I got fond of Tomorrow Night and I use it for the most part of the last 5 years. Recently I got annoyed by some color choices of the theme (the background and line highlight are a bit odd in my opinion), so I kept looking.

I decided to give /Doom-One/ a try, and so far I'm enjoying. I will admit that the purple-ish feeling of the palette is not my style, but overall, I'm not finding a bed choice.

So, to make /Doom-One/ the default theme, set the variable ~doom-theme~ to the symbol ~'doom-one~ to let Doom know what is the theme it should load:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
#+end_src

And because I like visual cues on my editor, I will turn on the ability to display *bold* and /italic/ faces for the theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-themes-enable-bold t
      doom-themes-enable-italic t)
#+end_src

The one complain I have on Doom theme in general, is the conflict =solaire-mode= has with =mixed-pitch=. If you turn both on, you will lose the variable pitch font. Until somehow, someone fix this, I will disable =solaire= mode to keep the editor UX consistent with my requirements:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! solaire-mode :disable t)
#+end_src

*** Typography
This section requires an important disclaimer to the reader. In majority of the cases, one should not /need/ to customize their fonts the way I'm doing it. Doom Emacs has a system to configure the editor fonts, and one should prefer to use such systems instead of this particular configuration.

Doom exposes five (optional) variables for controlling fonts:

- ~doom-font~ :: The global font used by Emacs;
- ~doom-big-font~ :: Used for ~doom-big-font-mode~, which you can use for presentations or streaming;
- ~doom-variable-pitch-font~ :: Font used for prose text (if you configure such modes to accept variable pitch fonts);
- ~doom-serif-font~ :: The default font to use for the fixed-pitch-serif face;
- ~doom-unicode-font~ :: Fallback font for Unicode glyphs;

They all accept either a font-spec, a font string (e.g. "Input Mono-12"), or a =xlfd= font string. You generally only need ~doom-font~ and ~doom-variable-pitch-font~, but I like to set ~doom-big-font~ as well, to make sure any time I switch to a presentation mode, it still feels like I have the same editor, but with a bigger font.

With that out of the way, I need to explain what is, and why my /typography/ configuration exists.

#+begin_center
◆
#+end_center

In the past years, I've got involved in some projects where I worked directly with the UX team on visual identity tasks. One of the first thing I got used to do, is to define the typography of the project. But what is typography? According to the wikipedia:

#+begin_quote
*Typography* is the art and technique of arranging type to make written language legible, readable and appealing when displayed.
#+end_quote

In the case of my configuration, I can define typography as a set of rules regarding displayed text that I want to use regardless the mode Emacs is in. Or simply put:

Text in my editor must be consistent, and look good.

To achieve this, I have to define said rules, and create a mechanism that will help me get the editor to behave the way I want. The one exception are the colors used on text elements. I want to let this particular trait to the theme I'm using.

The first rule to define is the simplest one: which fonts to use throughout the editor.

Currently, I narrowed my selection to these 3 fonts:

- [[https://github.com/iaolo/iA-Fonts][iA Writer Mono]] :: Used as my default monospaced font. The actual font I'm using is the [[https://www.nerdfonts.com/][Nerd Fonts]] version, known as /"iMWritingMonoS Nerd Font"/ due to its support for the =all-the-icons= package;
- [[https://github.com/iaolo/iA-Fonts][iA Writer Quattro]] :: Used as my default font for prose writing. For this font in particular, I can't use the Nerd Fonts version, nor the version distributed through [[https://brew.sh/][Homebrew]]. These versions, use the static version of the font that does not support different weights. For my configuration I use the [[https://github.com/iaolo/iA-Fonts/tree/master/iA%20Writer%20Quattro/Variable][Veriable]] version of the font;
- [[https://github.com/googlefonts/roboto][Roboto]] :: Used on UI elements like the project drawer, tab names, and tooltips;

To install the [[https://github.com/iaolo/iA-Fonts][iA Writer Mono]] and the [[https://github.com/googlefonts/roboto][Roboto]], one can use [[https://brew.sh/][Homebrew]] on macOS:

#+caption: Commands to install fonts with Homebrew
#+begin_src shell :tangle no
brew tap homebrew/cask-fonts
brew install --cask font-roboto font-im-writing-nerd-font
#+end_src

But for the [[https://github.com/iaolo/iA-Fonts][iA Writer Quattro]] you have to use to install it manually because the version offered by Homebrew is the static version of the font, which does not come with all the weights available. The correct font to install here is the /variable/ type.

To install the correct font, first download it using =curl=:

#+caption: Commands to download the iA Writer font
#+begin_src shell :tangle no
cd ~/Downloads && {
 curl -O 'https://github.com/iaolo/iA-Fonts/raw/master/iA%20Writer%20Quattro/Variable/iAWriterQuattroV.ttf'
 curl -O 'https://github.com/iaolo/iA-Fonts/raw/master/iA%20Writer%20Quattro/Variable/iAWriterQuattroV-Italic.ttf'
 cd -
}
#+end_src

Then, run the following AppleScript to perform the installation:

#+caption: Apple Script used to install iA Writer fonts
#+begin_src shell :tangle no
osascript <<'END'
  set theDownloadsFolder to get path to Downloads folder
  tell application "Finder"
    set allFonts to every file of theDownloadsFolder whose name starts with "iAWriterQuattroV"
  end tell

  repeat with theFont in allFonts
    tell application "Finder"
        open theFont
    end tell

    tell application "Font Book"
        activate
        set theFontWindow to the first window
    end tell

    tell application "System Events"
        tell process "Font Book"
            tell window 1
                tell group 1
                    click button "Install Font"
                end tell
            end tell
        end tell
    end tell
  end repeat
END
#+end_src

The rest of the rules are more subjective, and in all honesty, the methodology I used to decide which slant, and weight to use to each one of the text elements is non existent. I simply tried, checked how it looked, and asked myself, /"Is this a nice looking element?"/. If the answer was yes, I kept the configuration.

For the size, I started with the headline level 1 and configure it to be as big as it could be without looking disproportional to the text. Then, I reduced the size for the next level gradually until I get to the 8^{th} one, guaranteeing that it would not be smaller than the normal font size.

In practice, this means:

| Headline Level | Proportional size | Multiplier |
|----------------+-------------------+------------|
| Level 1        |              100% |        2.0 |
| Level 2        |               80% |        1.8 |
| Level 3        |               60% |        1.6 |
| Level 4        |               40% |        1.4 |
| Level 5        |               30% |        1.3 |
| Level 6        |               20% |        1.2 |
| Level 7        |               10% |        1.1 |
| Level 8        |                0% |        1.0 |

To make my typography rules easy to refer to, I create one face for each rule as follows:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defface my-default-mono `((t :font ,(font-spec :family "iMWritingMonoS Nerd Font"
                                                :size 16)))
  "Default monospaced font used on majority of the buffers."
  :group 'my-typography)

(defface my-big-face-mono `((t :font ,(font-spec :family "iMWritingMonoS Nerd Font"
                                                 :size 26)))
  "Monospaced font used on presentation mode."
  :group 'my-typography)

(defface my-default-ui `((t :font ,(font-spec :family "Roboto"
                                              :size 16)))
  "Extra face used on UI elements."
  :group 'my-typography)

(defface my-ui-window-header `((t :inherit my-default-ui
                                  :height 0.8))
  "Face used on decorative buffer headers."
  :group 'my-typography)

(defface my-default-prose `((t :font ,(font-spec :family "iA Writer Quattro V"
                                                 :size 18)))
  "Default variable pitch font used on prose writing."
  :group 'my-typography)

(defface my-document-title `((t :inherit my-default-prose
                                :height 2.4
                                :weight light
                                :slant normal))
  "Face used for document titles."
  :group 'my-typography)

(defface my-headline-1 `((t :inherit my-default-prose
                            :height 2.0
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-2 `((t :inherit my-default-prose
                            :height 1.8
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-3 `((t :inherit my-default-prose
                            :height 1.6
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-4 `((t :inherit my-default-prose
                            :height 1.4
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-5 `((t :inherit my-default-prose
                            :height 1.3
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-6 `((t :inherit my-default-prose
                            :height 1.2
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-7 `((t :inherit my-default-prose
                            :height 1.1
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-8 `((t :inherit my-default-prose
                            :height 1.0
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-uri-face `((t :inherit link))
  "Face used to display URIs."
  :group 'my-typography)
#+end_src

The goal is to customize the fonts I want to have follow one of these rules by resetting all its values to ~'unspecified~ and inheriting one of my typography faces.

To help the tedious task of resetting a face, I want to have a helper function that will do the work for me:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defsubst my-typography-reset (&rest faces)
  "Mark all face attributes from each face on FACES as `unspecified'."
  (custom-set-faces!
            `(,faces
              :family unspecified
              :foundry unspecified
              :width unspecified
              :height unspecified
              :weight unspecified
              :slant unspecified
              :underline unspecified
              :overline unspecified
              :strike-through unspecified
              :box unspecified
              :stipple unspecified
              :font unspecified
              :fontset unspecified
              :extend unspecified)))
#+end_src

The astute reader might ask: /"Why not have this function do the whole work of resetting the font and assign an inheritance?"/

Unfortunately at this point, the answer is not clear. When I tried to implement the /one-shot/ function, the target face would not get the inheritance value, and fonts were all messed up.

By splitting the process into cleaning and then setting, Emacs seams to behave as expected.

#+begin_note
If you know what is going on here, please let me know. I'll be more than happy to learn and credit you for that!
#+end_note

#+begin_center
◆
#+end_center

To start the configuration, per-se, I will get the Doom's font system configured accordingly to my typography:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-font (face-attribute 'my-default-mono :font)
      doom-big-font (face-attribute 'my-big-face-mono :font)
      doom-variable-pitch-font (face-attribute 'my-default-prose :font))
#+end_src

It would be great if Doom could accept a /face/ as the value for these variables, but unfortunately, it does not. Until this change, I have to live with this anonymous face that copy the =font= attribute from my typography face.

The next step is to make sure the base faces used on the editor match my base typography. The process to do so is the same I will use throughout this document whenever I find a mode that I need to adjust to match the defined typography.

I first clean up all styles except color on the faces I want to configure, in this case the faces are =fixed-pitch= and =variable-pitch=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset 'fixed-pitch 'variable-pitch)
#+end_src

Then I set each face inheritance to the correct typography face:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(fixed-pitch :inherit my-default-mono)
  '(variable-pitch :inherit my-default-prose))
#+end_src

At his point, Emacs have ~'default~, ~'fixed-pitch~, and ~'variable-pitch~ faces matching my selection of fonts. This is, probably, a major part on the typography configuration. The rest of my setup, are individual packages, which I will configure once they show up in this document.

To close out the typography section, I like to enable font smoothing on macOS. To do so, simply set ~ns-use-thin-smoothing~ to =t=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq ns-use-thin-smoothing t)
#+end_src

*** Iconography
Doom offers the =all-the-icons= package, which allow one to insert Unicode glyphs on buffers. That is a great start, but the problem I see here is how inconsistent the size of these icons are.

The idea for this section is to create a list of curated icons, adjusted to occupy exactly 2 ASCII characters on the buffer. This allows for a better alignment of text when we use an Icon.

I will create an /Association List/ to store symbols associated with an adjusted icon:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defconst my-supported-icons
  (list 'assign       (all-the-icons-material "assignment_ind"          :height 0.95 :v-adjust -0.17)
        'bug          (all-the-icons-material "bug_report"              :height 0.95 :v-adjust -0.17)
        'busy         (all-the-icons-material "event_busy"              :height 0.95 :v-adjust -0.17)
        'calendar     (all-the-icons-octicon  "calendar"                :height 1.05 :v-adjust 0.0)
        'checked      (all-the-icons-material "check_box"               :height 0.95 :v-adjust -0.17)
        'checklist    (all-the-icons-octicon  "checklist"               :height 0.95 :v-adjust 0.1)
        'contact-add  (all-the-icons-material "person_add"              :height 0.95 :v-adjust -0.17)
        'error        (all-the-icons-material "error_outline"           :height 0.95 :v-adjust -0.17)
        'globe        (all-the-icons-faicon   "globe"                   :height 1.15 :v-adjust -0.05)
        'help         (all-the-icons-material "live_help"               :height 0.95 :v-adjust -0.22)
        'history      (all-the-icons-material "history"                 :height 0.95 :v-adjust -0.17)
        'idea         (all-the-icons-material "lightbulb_outline"       :height 0.95 :v-adjust -0.17)
        'inbox        (all-the-icons-material "inbox"                   :height 0.95 :v-adjust -0.15)
        'journal      (all-the-icons-material "book"                    :height 0.95 :v-adjust -0.15)
        'list         (all-the-icons-faicon   "list"                    :height 0.93 :v-adjust -0.05)
        'loop         (all-the-icons-material "loop"                    :height 0.95 :v-adjust -0.17)
        'meeting      (all-the-icons-material "date_range"              :height 0.95 :v-adjust -0.15)
        'new          (all-the-icons-material "new_releases"            :height 0.95 :v-adjust -0.17)
        'notes        (all-the-icons-material "library_books"           :height 0.95 :v-adjust -0.1)
        'pause        (all-the-icons-material "pause_circle_outline"    :height 0.95 :v-adjust -0.17)
        'postit       (all-the-icons-faicon   "sticky-note"             :height 1.15 :v-adjust 0.05)
        'project      (all-the-icons-octicon  "briefcase"               :height 1.05 :v-adjust 0.05)
        'review       (all-the-icons-material "rate_review"             :height 0.95 :v-adjust -0.15)
        'semi-checked (all-the-icons-material "indeterminate_check_box" :height 0.95 :v-adjust -0.17)
        'snooze       (all-the-icons-material "snooze"                  :height 0.95 :v-adjust -0.17)
        'stop         (all-the-icons-octicon  "stop"                    :height 1.05 :v-adjust -0.05)
        'timer        (all-the-icons-material "timer"                   :height 0.95 :v-adjust -0.15)
        'unchecked    (all-the-icons-material "check_box_outline_blank" :height 0.95 :v-adjust -0.17)
        'visibility   (all-the-icons-material "visibility"              :height 0.95 :v-adjust -0.17)
        'wait         (all-the-icons-material "hourglass_empty"         :height 0.95 :v-adjust -0.17))
  "Property list with all supported icons from my configuration.")
#+end_src

In order to allow other parts of this configuration to leverage the curated icons, I'll create a predicate function to  check if a given symbol has an icon associated with it:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-supported-icons-p (icon)
  "Return t if the symbol given on ICON, is one associated with supported icon."
  (and (boundp 'my-supported-icons)
       (listp my-supported-icons)
       (plist-member my-supported-icons icon)))
#+end_src

I want to also create a thin-wrapper around the ~plist-get~ to retrieve the icon string for a given symbol:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-raw-icon (icon)
  "This function returns the requested ICON as if you're calling the
`all-the-icons-'* functions directly.

Icons supported by this function were all optimized to use exactly 2 characters
of space when used with the font and size defined in the main configuration.

Check th documentation of `my-supported-icons' to see the list of supported
icons."
  (plist-get my-supported-icons icon))
#+end_src

And to finalize my icons configuration, I need to expose a function where one (me in this case) will call it to get a curated icon with a given color (this is the only function in this section that a user should call to get an icon).

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-icon (icon &optional color)
  "This function returns the requested ICON as a 2-characters string,
propertized to display the associated icon from the `all-the-icons' package. It
uses the COLOR arg to 'paint' the icon.

Check documentation of the function `my-raw-icon' for a list of supported
icons."
  (cond ((eq color 'raw) (my-raw-icon icon))
        (color (propertize "--"
                   'face `(:foreground ,color)
                   'display (my-raw-icon icon)))
        (t (propertize "--"
                   'face `(:foreground ,(face-attribute 'default :foreground))
                   'display (my-raw-icon icon)))))
#+end_src

** Editor Tabs
I've been all over the place regarding the use of tabs on editors. I use to think they were useless, since all files on my editor were buffers, not tabs. I though that using tabs as a sort of layout manager was a great idea, because I would have the visual cue of /workspaces/ I had configured.

Recently, I spent time thinking about this and I changed my mind regarding tabs. First of all, I believe the common knowledge that one tab represents one file, is too ingrained into our collective minds by all other software that use them (web browsers, IDEs, file managers, etc.). This causes a weird feeling when I look to the tabs and they do not represent opened files. Also, as I work on my editor, I lose track of files opened without tabs.

For some Emacs users, all these arguments are silly because they are too used to the way Emacs works. But I believe that this argument should be the other way around. Because of the way Emacs developers decided to use the tab paradigm inside the editor, Emacs users accepted and got used to it.

But, as if to point out things I'm arguing for, there are way too many packages that say they /fix the Emacs window system/ on GitHub these days.

On 2020, I read a blog post from [[https://andreyorst.gitlab.io/][Andrey Listopadov]] about his desire to have [[https://andreyorst.gitlab.io/posts/2020-05-07-making-emacs-tabs-work-like-in-atom/][Emacs tabs behaving more like tabs on Atom]]. The post itself is a really good read, but I would like to reproduce here Andrey's description of how he believes the tab behavior should be:

#+begin_quote
In Emacs, however, we can’t close tab via close button, because it will cycle buffers, so instead we can switch to second policy of killing buffer instead. But it will not work either, because it will not kill the window, and it will kill buffer in all windows. So how do we fix this?

First let’s establish some logical rules:

- Buffer can exist without a tab, but tab can not exist without a buffer,
- If tab was closed buffer should be killed only if there are no tabs for this buffer left,
- If tab was closed and there are no more tabs in the window, window should be killed.

These three rules are basically how tabs work in modern editors.
#+end_quote

The configuration you're reading here is almost a copy from Andrey's posts (there is a sequel to the aforementioned post called [[https://andreyorst.gitlab.io/posts/2020-05-10-making-emacs-tabs-look-like-in-atom/][Making Emacs tabs look like in Atom]], that I also copy snippets in order fully configure tabs here.) with minor modifications to adjust it to my code style.

The way to achieve this configuration, is to define a set of =tab-line= variables and let Emacs do its thing.

My tab configuration uses dynamic values in almost all of it, but there are two constants that I have to decide beforehand: ~tab-line-tab-min-width~ and ~tab-line-tab-max-width~.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst tab-line-tab-min-width 20
  "Minimum width of a tab in characters.")

(defconst tab-line-tab-max-width 70
  "Maximum width of a tab in characters.")
#+end_src

It might look an exaggeration to use the values I chose, but since I will use a variable pitch face to draw the tabs, these numbers become more realistic.

So let's configure the faces used on my tabs:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs--setup-faces-h ()
  "Configure the `tab-line-mode' user interface."
  (let* ((base (if (and (facep 'solaire-default-face)
                        (not (eq (face-attribute 'solaire-default-face :background) 'unspecified)))
                   (face-attribute 'default :background)
                 (face-attribute 'mode-line :background)))
         (bg (if (and (facep 'solaire-default-face)
                      (not (eq (face-attribute 'solaire-default-face :background) 'unspecified)))
                 (face-attribute 'solaire-default-face :background)
               (face-attribute 'default :background)))
         (fg (face-attribute 'default :foreground))
         (dark-fg (face-attribute 'shadow :foreground))
         (overline (face-attribute 'highlight :background))
         (box-width (/ my-line-pixel-height 2))
         (box-base (when (> box-width 0) (list :line-width box-width :color base)))
         (box-bg (when (> box-width 0) (list :line-width box-width :color bg))))
    (set-face-attribute 'tab-line nil
                        :background base
                        :foreground dark-fg
                        :overline base
                        :inherit 'my-default-ui
                        :box box-base)
    (set-face-attribute 'tab-line-tab nil
                        :foreground dark-fg
                        :background bg
                        :inherit 'my-default-ui
                        :box box-bg)
    (set-face-attribute 'tab-line-tab-inactive nil
                        :foreground dark-fg
                        :background base
                        :inherit 'my-default-ui
                        :box box-base)
    (set-face-attribute 'tab-line-tab-current nil
                        :foreground fg
                        :background bg
                        :inherit 'my-default-ui
                        :overline overline
                        :box box-bg)
    (set-face-attribute 'tab-line-highlight nil
                        :foreground fg
                        :background nil
                        :inherit 'tab-line-tab
                        :overline overline
                        :box box-bg)
    (set-face-attribute 'tab-line-close-highlight nil
                        :foreground overline
                        :overline overline
                        :background nil
                        :inherit 'tab-line-tab
                        :box box-bg)))
#+end_src

And I need to make sure I call this function after Doom loads the editor's theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'doom-load-theme-hook #'my-tabs--setup-faces-h)
#+end_src

To configure the look and feel of /non-tab/ elements of the =tab-line=, I need to set the ~tab-line-right-button~, ~tab-line-left-button~, ~tab-line-new-button-show~, and ~tab-line-separator~ variables:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-right-button (propertize (if (char-displayable-p ?▸) " ▸ " " > ")
                                          'keymap tab-line-right-map
                                          'mouse-face 'tab-line-highlight
                                          'help-echo "Click to scroll right")
        tab-line-left-button (propertize (if (char-displayable-p ?◂) " ◂ " " < ")
                                         'keymap tab-line-left-map
                                         'mouse-face 'tab-line-highlight
                                         'help-echo "Click to scroll left")
        tab-line-new-button-show nil
        tab-line-separator ""))
#+end_src

And to configure the tab itself, I need to set the ~tab-line-close-button-show~, ~tab-line-close-button~, and the ~tab-line-tab-name-function~ variables:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-close-button-show t
        tab-line-close-button (propertize (format "%s " (all-the-icons-material "close"))
                                          'keymap tab-line-tab-close-map
                                          'mouse-face 'tab-line-close-highlight
                                          'face 'tab-line-tab-curent
                                          'help-echo "Click to close tab")
        tab-line-tab-name-function #'my-tabs-name-buffer))
#+end_src

While the ~tab-line-close-button-show~ and the ~tab-line-close-button~ variables control the appearance of the tab close button, the ~tab-line-tab-name-function~ is responsible for everything else on the tab. The ~my-tabs-name-buffer~ function will return a string representing the tab name for each tab, and is also this function's responsibility to return the normalized tab size in form of blank spaces:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-name-buffer (buffer &rest _buffers)
  "Create name for tab with padding and truncation.

If buffer name is shorter than `tab-line-tab-max-width' it gets centered with
spaces, otherwise it gets truncated, to preserve equal width for all tabs. This
function also tries to fit as many tabs in window as possible, so if there are
no room for tabs with maximum width, it calculates new width for each tab and
truncates text if needed. You can set the minimal width with
`tab-line-tab-min-width' variable."
  (with-current-buffer buffer
    (let* ((window-width (window-width (get-buffer-window)))
           (close-button-size (if tab-line-close-button-show
                                  (length (substring-no-properties tab-line-close-button))
                                0))
           (tab-amount (length (funcall tab-line-tabs-function)))
           (window-max-tab-width (/ window-width tab-amount))
           (tab-width (- (cond ((>= window-max-tab-width tab-line-tab-max-width)
                                tab-line-tab-max-width)
                               ((< window-max-tab-width tab-line-tab-min-width)
                                tab-line-tab-min-width)
                               (t window-max-tab-width))
                         close-button-size))
           (buffer-name (string-trim (buffer-name)))
           (name-width (length buffer-name)))
      (if (>= name-width (- tab-width 3))
          (concat  " " (truncate-string-to-width buffer-name (- tab-width 3)) "… ")
        (let* ((padding (make-string (/ (- tab-width name-width) 2) ?\s))
               (buffer-name (concat padding buffer-name))
               (name-width (length buffer-name)))
          (concat buffer-name (make-string (- tab-width name-width) ?\s)))))))
#+end_src

The reader might have noticed I use the size of the list returned by the function ~tab-line-tabs-function~ to calculate single tab size, and as you imagine, the function symbol used in this variable is responsible to return a list of tabs on the current window, so I will also use such function to filter some unwanted buffers on the tab bar. The function docstring, explains these exceptional cases in a bit more detail:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-mode-persp-window ()
  "Return a list of buffer tabs of the current window.

This function take in account the active perspective (or workspace) so it does
not display tabs from other perspectives on the current one.

There are 4 types of buffer that this function handles:

1. Real buffers

   These buffers are the normal buffers that have a tab associated with them. To
   be a real buffer, the function `doom-real-buffer-p' must return t for the
   buffer.

2. Popup buffers (or non-real buffers)

   These are the inverse of real buffers.

3. Org capture buffers

   These buffers are the ones created to perform the `org-capture'. Such buffers
   should never have a tab associated with them.

4. Dired buffers

   These are real buffers that should never exist in more than one per window.
   When jumping from one Dired buffer to another, Emacs creates one buffer per
   directory, but the tab bar should not display any other then the current
   buffer."
  (let ((win-buffs (tab-line-tabs-window-buffers))
        (last-dired-buf (seq-find 'doom-dired-buffer-p (buffer-list (selected-frame)))))
    (reverse (seq-filter (lambda (buf)
                           (let ((buf-name (buffer-name buf)))
                             (and (member buf win-buffs)
                                  (doom-real-buffer-p buf)
                                  (not (string-prefix-p buf-name "CAPTURE-"))
                                  (or (not (doom-dired-buffer-p buf))
                                      (eq buf last-dired-buf)))))
                         (funcall tab-line-tabs-buffer-list-function)))))
#+end_src

And as with the ~tab-line-tabs-function~, the ~tab-line-tabs-buffer-list-function~ holds a symbol of a function that returns all buffers to consider during ~tab-line-tabs-function~ execution, and I should set them to their proper functions, unfortunately the ~persp-current-buffers~ (which is the function we need to call), is a macro, and according to the Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html][documentation]], we can't pass macros to ~funcall~ or ~apply~.

To workaround this problem, I will create an alias function to call the same functions the ~persp-current-buffers~ macro do:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defalias 'my-persp-current-buffers
  (lambda () (persp-buffers (persp-curr)))
  "Wrapper for the `persp-current-buffers' macro.")
#+end_src

Now we can properly define the two variables we need to make =tab-line= find the tab buffers:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-tabs-function #'my-tabs-mode-persp-window
        tab-line-tabs-buffer-list-function #'my-persp-current-buffers))
#+end_src

The last variable to configure is the ~tab-line-exclude-modes~. This variable holds a list of modes that will not have ~tab-line-mode~ enabled on them, even when ~global-tab-line-mode~ gets enabled:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-exclude-modes '(+doom-dashboard-mode
                                 cfw:calendar-mode
                                 Info-mode
                                 calendar-mode
                                 ediff-mode
                                 eshell-mode
                                 help-mode
                                 helpful-mode
                                 imenu-list-major-mode
                                 lexic-mode
                                 process-menu-mode
                                 Man-mode
                                 WoMan-mode
                                 term-mode
                                 treemacs-mode
                                 vterm-mode
                                 wordnut-mode
                                 reb-mode)))
#+end_src

Even with the ~tab-line-exclude-modes~ list, some /non-real/ buffers get displayed. I need to create an extra function to help me get rid of the =tab-line= when I load such buffers:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-hide-tab-line-maybe-h ()
  "Disable `tab-line-mode' for non-real buffers.

For a definition of what is a non-real buffer, check the documentation of
`doom-real-buffer-p'."
  (when (not (doom-real-buffer-p (current-buffer)))
    (tab-line-mode -1)))
#+end_src

With the helper function defined, I need to make sure I call it when I switch buffers. The reason for that is that I could explicitly request to load a /non-real/ buffer, which would create the =tab-line= on such buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'doom-switch-buffer-hook #'my-tabs-hide-tab-line-maybe-h)
#+end_src

Also, when Emacs calls the ~window-configuration-change-hook~ hooks, I need to clean all =tab-line= cache to make sure Emacs will re-consider all the proper buffers when re-displaying it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'window-configuration-change-hook #'my-tabs--drop-caches-h)
#+end_src

The implementation of ~my-tabs--drop-caches-h~ simply /nullify/ the value of the ~tab-line-cache~ window parameter for all windows:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs--drop-caches-h ()
  "Drops `tab-line' cache in every window."
  (dolist (window (window-list))
    (set-window-parameter window 'tab-line-cache nil)))
#+end_src

With all that in place, we can make sure the =tab-line= gets loaded when Emacs start:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! tab-line
  :when window-system
  :hook ((after-init . global-tab-line-mode)))
#+end_src

*** Tab actions
There are two main actions that I need to address here: selection and closing.

I would like to start talking about the later. Unfortunately, the Emacs implementation of ~tab-line-close-tab~ does not leave room to customize its behavior the way I want it. Instead, I will implement my own version (more like "I'll copy Andrey's version and change it a bit"):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-close-buffer-tab (buffer-or-name &optional window)
  (let ((buffer (get-buffer buffer-or-name))
        (window (or window (get-buffer-window))))
    (if window
        (with-selected-window window
          (let ((tab-list (my-tabs-mode-persp-window))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (my-tabs-mode-persp-window) list))
                                          (window-list) nil))))
            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
                  (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
                  (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
              (and (kill-buffer buffer)
                   (unless (cdr tab-list)
                     (ignore-errors (delete-window window)))))))
      (if (persp-buffer-in-other-p buffer)
          (persp-remove-buffer buffer)
        (kill-buffer buffer)))))
#+end_src

With the function implemented, I need to override the original one with it using an advice:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-tabs-close-tab-a (&optional mouse-event)
  "Close the selected tab.

If buffer on tab is present in another window, close the tab by using
`bury-buffer' function. If buffer on tab is unique to all existing windows, kill
the buffer with `kill-buffer' function. Lastly, if no tabs left in the window,
it will delete it with `delete-window' function."
  :override 'tab-line-close-tab
  (let* ((posnp (and mouse-event (event-start mouse-event)))
         (window (and posnp (posn-window posnp)))
         (buffer (or (and posnp (get-pos-property 1 'tab (car (posn-string posnp))))
                     (current-buffer)))
         (window (or window (get-buffer-window buffer))))
    (my-tabs-close-buffer-tab buffer window)
    (force-mode-line-update)))
#+end_src

Now, any code calling the ~tab-line-close-tab~ will use the algorithm defined in this section.

#+begin_center
◆
#+end_center

The next and final action to handle is actually a group of actions related to /switching between tabs/.

The first step to configure tab switching, is to create a function that allows me to switch to any tab, by passing a tab to it. The only special thing about this function is that you can pass a buffer or an association list representing a tab. Other than that, this function behaves much like the ~switch-to-buffer~ one:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to-tab (tab)
  "Switch to the buffer associated with TAB."
  (let ((buffer (if (bufferp tab) tab (cdr (assq 'buffer tab)))))
    (when (bufferp buffer)
        (switch-to-buffer buffer))))
#+end_src

Next, I need a way to select a tab by its position of the displayed tabs:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to (pos)
  "Switch to the tab on position POS.

If POS is negative, access the tab on the reverse order.

If POS is bigger than the number of tabs, return nil. The same is valid for
negative numbers, so if POS is negative and its absolute value minus 1 is bigger
than the number of tabs, return nil."
  (let* ((tabs (funcall tab-line-tabs-function))
         (tabs (if (< pos 0) (reverse tabs) tabs))
         (pos (if (< pos 0) (1- (- pos)) pos))
         (tab (nth pos tabs)))
    (unless (my-tab-line-switch-to-tab tab)
      (user-error "There is no tab on position %s" (1+ pos)))))
#+end_src

And a helper function to select the last tab on the list:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to-final ()
  "Switch to the last tab."
  (interactive)
  (let* ((tab (car (last (funcall tab-line-tabs-function)))))
    (unless (my-tab-line-switch-to-tab tab)
      (user-error "Tab line is not visible to go to the last tab"))))
#+end_src

These functions should be enough to allow me to switch tabs on any way I defined here. To get a good set of key bindings, I need to create aliases for calling ~my-tab-line-switch-to~ from 1 to 9:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(dotimes (i 9)
  (defalias (intern (format "my-tab-line-switch-to-%d" i))
    (lambda () (interactive) (my-tab-line-switch-to i))
    (format
     "Thin wrapper around `+workspace/switch-to' function where we pass #%d as the INDEX parameter."
     (1+ i))))
#+end_src

And my keymap for all these functions should allow me to switch tabs using =Cmd= plus a number from =1= to =9=. The =Cmd-0= shortcut will call the ~my-tab-line-switch-to-final~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after tab-line
      :ne "s-1" #'my-tab-line-switch-to-0
      :ne "s-2" #'my-tab-line-switch-to-1
      :ne "s-3" #'my-tab-line-switch-to-2
      :ne "s-4" #'my-tab-line-switch-to-3
      :ne "s-5" #'my-tab-line-switch-to-4
      :ne "s-6" #'my-tab-line-switch-to-5
      :ne "s-7" #'my-tab-line-switch-to-6
      :ne "s-8" #'my-tab-line-switch-to-7
      :ne "s-9" #'my-tab-line-switch-to-8
      :ne "s-0" #'my-tab-line-switch-to-final

      (:prefix "g"
       :desc "Go to tab on the right" :n "t" #'tab-line-switch-to-next-tab
       :desc "Go to tab on the left"  :n "T" #'tab-line-switch-to-prev-tab))
#+end_src

One final configuration I need to do is to make sure Emacs selects the correct tab when I click on it with the mouse:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-tabs-select-tab-a (&optional e)
  "Advice to select the buffer window of a tab when clicking on the tab."
  :after 'tab-line-select-tab
  (select-window (posn-window (event-start e))))
#+end_src

*** Windows
It's impossible to get the tab configuration right without adjusting the Emacs window behavior.

The main behavior I want to guarantee, is that Emacs should close a window if there are no buffers left on the list of previous buffers:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-close-window-when-kill-buffer-h (&optional buffer-or-name)
  (let* ((buf (get-buffer (or buffer-or-name (current-buffer))))
         (win (get-buffer-window buf)))
    (when (and win (my-window-single-buffer-p win))
      (delete-window win))))
#+end_src

Because this function needs to know if there are no buffer lefts on the list of buffers associated with the window, I will implement a helper function for that:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defsubst my-window-single-buffer-p (&optional win)
  (let ((win (or win (selected-window))))
    (or (window-dedicated-p win)
        (not (or (window-next-buffers win)
                 (window-prev-buffers win))))))
#+end_src

Now I just need to make sure Emacs calls the ~my-close-window-when-kill-buffer-h~ function when I kill a buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-buffer-hook 'my-close-window-when-kill-buffer-h)
#+end_src

These covers most of the closing behavior regarding windows. The one exception is the ~kill-current-buffer~ that needs to not switch buffers as we kill the current buffer. I will implement this behavior as a /before/ advice to the ~kill-current-buffer~ function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-close-window-when-no-buffer-a (&rest _)
  :before-until #'kill-current-buffer
  (my-save-all-buffers-a)
  (let ((buf (current-buffer))
        (tabs (my-tabs-mode-persp-window)))
    (cond
     ((window-dedicated-p) (delete-window) t)
     ((eq buf (doom-fallback-buffer)) (message "Can't kill the fallback buffer.") t)
     ((doom-real-buffer-p buf)
      (let ((doom-inhibit-switch-buffer-hooks-original doom-inhibit-switch-buffer-hooks)
            (inhibit-redisplay t)
            buffer-list-update-hook)
        (if (memq buf tabs)
            (progn
              (when (and (doom-real-buffer-p buf)
                         (buffer-file-name buf)
                         (buffer-modified-p buf)
                         (not (y-or-n-p (format "Buffer %s has unsaved changes; kill it anyway?" buf))))
                (user-error "Aborted"))
              (tab-line-close-tab))
          (with-current-buffer buf
            (restore-buffer-modified-p nil))
          (kill-buffer buf))
        (setq doom-inhibit-switch-buffer-hooks doom-inhibit-switch-buffer-hooks-original))
      (run-hooks 'buffer-list-update-hook)
      t))))
#+end_src

To finish the window changes, I need to make sure Doom does not switch to the fallback buffer (a.k.a. the Dashboard buffer) when there are no more buffers left on the window:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(advice-remove 'kill-current-buffer #'doom--switch-to-fallback-buffer-maybe-a)
#+end_src

** Special modes
The configuration in this section, belongs to some modes that I use all over the place or that are not big enough to justify their own section in this document.

In practice, most of the configurations here are about the mode's appearance, and where they show their content.

*** Info mode
The Info mode is where all user manuals exist. Up to now, I'm not used to read and search through the manuals, but I feel this is a habit I must acquire.

First I need to make the manuals to /look/ nicer (if you're rolling your eyes right now, have a remembering read into the section [[Appearances]]).

Although this is not a radical change, there are two font lock additions I want to do. The first is a symbol to represent the /menu/ for the current info page, and the second is to replace the =*= character as the list item markup, by the character I will use on all other modes that deal with lists:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! info
  (font-lock-add-keywords
   'Info-mode
   `(("^\\(\\*\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))
     ("^[\t ]*\\(\\*\\) Menu\\(:\\)"
      (0 (prog1 ()
           (compose-region (match-beginning 1) (match-end 1) "☰")
           (put-text-property (match-beginning 2) (match-end 2) 'invisible t)
           )))) t))
#+end_src

There is a package called =info+.el=, available through the Emacs Wiki, that fontify the =Info-mode= buffer to make it look nicer.

Unfortunately the latest changes introduced in March broke the package on Emacs 27 and 28, so in order to still have the nice feature it provides with a version that still works on my Emacs, I need to /pin/ the package to the version that still works:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! info-plus :pin "5ecd4c1e3f1384bffb386e61a8e3788652e55c25")
#+end_src

Due to the nature of this package, we need to load it only when we need to fontify the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! info-plus :commands Info-toggle-fontify-all)
#+end_src

But when this actually happens? The best place to add this, is the hook ~Info-selection-hook~. First I need to define a function that will configure the mode when any info page gets selected:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info--fontify-info-h ()
  "Hook called to fontify the Info buffer.

This function lexically bind some configuration for the `into-plus' package,
and call the `Info-toggle-fontify-all' to perform the fontification work.

Notice we need to update the font lock overlays after this call to guarantee
the fontification didn't remove any important overlay."
  (let ((Info-fontify-angle-bracketed-flag nil)
        (Info-fontify-bookmarked-xrefs-flag nil)
        (Info-fontify-emphasis-flag nil)
        (Info-fontify-glossary-words nil)
        (Info-fontify-isolated-quote-flag nil)
        (Info-fontify-quotations nil)
        (Info-fontify-reference-items-flag nil)
        (Info-fontify-visited-nodes nil))
    (call-interactively 'Info-toggle-fontify-all)
    (font-lock-update)))
#+end_src

Then, I can hook it to the ~Info-selection-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-selection #'my-info--fontify-info-h)
#+end_src

The next step is to make sure the =Info-mode= respects the typography I defined earlier. First we clean up any outstanding setup to the faces that need to get adjusted:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset (cl-loop for i from 1 to 4 collect (intern (format "info-title-%d" i))))
(my-typography-reset 'info-menu-header)
#+end_src

And then, we modify all the faces to match my particular configuration:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(info-title-1 :inherit outline-1 :weight unspecified :extend unspecified)
  '(info-title-2 :inherit outline-2 :weight unspecified :extend unspecified)
  '(info-title-3 :inherit outline-3 :weight unspecified :extend unspecified)
  '(info-title-4 :inherit outline-4 :weight unspecified :extend unspecified)
  '(info-menu-header :inherit outline-5 :weight unspecified :extend unspecified)
  `(info-quoted-name :inherit font-lock-constant-face)
  `(info-isolated-quote :inherit info-quoted-name)
  `(info-isolated-backquote :inherit info-quoted-name)
  `(info-glossary-word :foreground ,(doom-color 'type 256)
                       :background ,(doom-darken 'type 0.7)
                       :box (:line-width (4 . 1) :color ,(doom-darken 'type 0.7) :style nil)
                       :inherit fixed-pitch)
  `(link-visited :foreground ,(doom-color 'violet 256))
  `(info-double-quoted-name :inherit font-lock-string-face)
  `(info-string :inherit font-lock-string-face)
  `(info-header-node :height 160
                     :inherit info-node)
  `(info-header-xref :height 160
                     :inherit info-xref))
#+end_src

There are two remaining configurations. The first one is to make the =Info-mode= buffer to match how it gets displayed on the editor. I will use =writeroom= to make the buffer centralized on the window, and will turn on =variable-pitch-mode=:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (variable-pitch-mode 1)
  (visual-line-mode 1))
#+end_src

With the function that will configure my buffer in place, I need to hook it to the mode initialization:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-mode #'my-info-buffer-config-h)
#+end_src

The last configuration for the =Info-mode= is *where* its buffer gets displayed. For me, it should show up on the right side of my screen. I can achieve that with a popup rule for the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*info\\*$"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)
#+end_src

*** Help mode and Man mode
I want to give a similar treatment I did to the =Info-mode= to both these modes, and like the =Info-mode=, the first thing to do is to create the functions that will configure these modes:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-help-man-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (visual-line-mode 1))
#+end_src

And then, hook them up to their modes hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! (help-mode
            helpful-mode
            Man-mode
            WoMan-mode)
           #'my-help-man-buffer-config-h)
#+end_src

The last step on these configuration is to add a popup rule for each mode to make their buffers to open on the right side of the editor:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*[Hh]elp"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)

(set-popup-rule! "^\\*\\(?:Wo\\)?Man "
  :slot 2   :vslot -1     :side 'right  :width 88 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0     :quit t)
#+end_src

*** Rainbow mode
The Rainbow mode is a small visual helper to display colors on the buffer, whenever it finds a string that can be a color.

I already configured a key binding (=SPC t R=) to toggle this mode.

What I still need to do, is to make sure that I use a fixed font when displaying the color text, unfortunately, the =rainbow-mode= uses an anonymous face to display the colors, so the only way for me to customize it, is to override the ~rainbow-colorize-match~ with a function that add any property I want to the face (in this case, to inherit from the ~fixed-pitch~ face):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-fontify-rainbow-colorize-match-a (color &optional match)
  "Return a matched string propertized with a face whose background is COLOR.

This function computes the foreground using `rainbow-color-luminance', and is
either white or black."
  :override 'rainbow-colorize-match
  (let ((match (or match 0)))
    (put-text-property
     (match-beginning match) (match-end match)
     'face `((:foreground ,(if (> 0.5 (rainbow-x-color-luminance color))
                               "white" "black"))
             (:background ,color)
             (:inherit fixed-pitch)))))
#+end_src

* Temporary workarounds
This section contain configurations that will get integrated on Doom on a relative short period of time. This means that sooner or later, sections here will get replaced by a better module from Doom.

** TODO Completion framework
What I call the completion framework, is what we use to incrementally select an input when using the interactive mode.

We call the standard interactive mode on Emacs [[https://www.gnu.org/software/emacs/manual/html_mono/ido.html][Ido]] ([[https://www.emacswiki.org/emacs/InteractivelyDoThings][Interactively Do Things]]), and users have been building packages to improve or replace it for ages. Among the most famous package are:

- Icomplete :: Bundled with Emacs;
- Helm :: One of the first heavy weight contender to replace Ido;
- Ivy :: Created as a lightweight version of Helm, with the goal to achieve parity with Help at a minimum;

When I was writing this document, one of the /new kids on the block/ for completion framework was a set of packages that I kindly named /Selectrum and Friends/. The list of packages that compose this set are:

- [[https://github.com/raxod502/selectrum][Selectrum]] :: A better solution for incremental narrowing in Emacs, replacing Helm, Ivy, and Ido;
- [[https://github.com/minad/marginalia][Marginalia]] :: Marginalia are marks or annotations placed at the margin of the page of a book or in this case helpful colorful annotations placed at the margin of the minibuffer for your completion candidates;
- [[https://github.com/oantolin/orderless][Orderless]] :: A completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order;
- [[https://github.com/raxod502/prescient.el][Prescient]] :: A library which sorts and filters lists of candidates, such as appear when you use a package like Ivy or Company;
- [[https://github.com/oantolin/embark/][Embark]] :: A sort of right-click contextual menu for Emacs, accessed through the embark-act command, offering you relevant actions to use on a target determined by the current context;
- [[https://github.com/minad/consult][Consult]] :: Provides handy commands based on the Emacs completion function completing-read, which allows to quickly select an item from a list of candidates with completion;

Unfortunately, these packages are not yet bundled in Doom, so I have to install and configure them here until the Pull Request [[https://github.com/hlissner/doom-emacs/pull/4664][#4664]] gets merged.

The appeal of /Selectrum and Friends/, is the fact they use the standard Emacs features to achieve their goals, this way, there is a better chance to not need to change my configuration in the future, even if I decide to use a different package for the completion UI.

To configure all these packages on Doom, I have to do it in the following order:

- Configure result filtering and mach highlights;
- Configure result sorting;
- Configure result item annotations (to display extra information for each completion candidate);
- Configure the completion UI;
- Configure contextual menu;
- Configure extra commands;
- Alter the standard behavior of Doom Emacs, to fit my preferences;

*** Filtering and highlighting
The first package I want to install is =orderless=. This package augment the standard Emacs completion system providing multiple matches for your input.

First, we need to add it to =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! orderless)
#+end_src

And then configure it with ~use-package!~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! orderless
  :defer t
  :init
  (setq orderless-component-separator "[ &]"
        orderless-matching-styles '(orderless-prefixes
                                    orderless-initialism
                                    orderless-regexp))
  :config
  (setq completion-styles '(orderless))
  (setq orderless-skip-highlighting (lambda () selectrum-active-p))
  (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
  (setq orderless-matching-styles '(orderless-regexp)
        orderless-style-dispatchers '(flex-if-twiddle
                                      without-if-bang)))
#+end_src

You might have noticed that the last configuration we perform on =orderless=, uses two functions not implemented by default. The idea on these two functions is to create extra dispatchers to allow us more control on our searches.

The first of the functions is ~flex-if-twiddle~. This dispatcher allows one to type a =~= on the input to trigger the /flex/ search style (which is a resemblance of fuzzy finder).

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun flex-if-twiddle (pattern _index _total)
  "Return the `orderless-flex' dispatcher if the search contains a ~ character."
  (when (string-suffix-p "~" pattern)
    `(orderless-flex . ,(substring pattern 0 -1))))
#+end_src

And the second one is ~without-if-bang~ which allow us to have a negation operator on our searches.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun without-if-bang (pattern _index _total)
  "Define a '!not' exclusion prefix for literal strings."
  (when (string-prefix-p "!" pattern)
    `(orderless-without-literal . ,(substring pattern 1))))
#+end_src

On company, the matching portions of candidates are not highlighted. That’s because ~company-capf~ is hard-coded to look for the ~completions-common-part~ face, and it only use one face (~company-echo-common~) to highlight candidates.

So, while you can’t get different faces for different components, you can at least get the matches highlighted in the sole available face with this configuration:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-orderless-match-with-one-face-a (fn &rest args)
  "Function to help company to highlight all candidates with just one face."
  :around 'company-capf--candidates
  (let ((orderless-match-faces [completions-common-part]))
    (apply fn args)))
#+end_src

*** Sorting
=orderless= works pretty well, but there is one aspect of it that bothers me: the lack of a sorting system. I couldn't decide if I should use =prescient= (recommended by the =selectrum= author) and lose the nice things I like about =orderless=, or use =orderless= and lose the sorting and remembering mechanism of =prescient=.

Then it hit me: why not use both?

The idea is to install =prescient= but not call ~(selectrum-prescient-mode 1)~. Instead, setup the two required hooks for remembering, and the one variable, later on =selectum=, to use the /preprocessing/ from =prescient=. So let's start with =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! selectrum-prescient)
#+end_src

Then, let's configure it, and set the persistent mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! selectrum-prescient
  :hook (selectrum-mode . selectrum-prescient-mode)
  :hook (selectrum-mode . prescient-persist-mode)
  :config
  (setq selectrum-preprocess-candidates-function #'selectrum-prescient--preprocess)
  (add-hook 'selectrum-candidate-selected-hook #'selectrum-prescient--remember)
  (add-hook 'selectrum-candidate-inserted-hook #'selectrum-prescient--remember))
#+end_src

*** Candidates annotations
The next package is =marginalia=. This package will add annotations on candidates depending on the context of it. Think about it as a sort of =ivy-rich=, but more organized and use to customize.

As with =ordeless=, we need to first, add it to the =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! marginalia)
#+end_src

Then, configure it using ~use-packages!~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! marginalia
  :hook (doom-first-input . marginalia-mode)
  :init
  (setq-default marginalia-annotators '(marginalia-annotators-heavy))
  :config
  (add-to-list 'marginalia-command-categories '(persp-switch-to-buffer . buffer)))
#+end_src

At this point, our completion system can filter its candidates (=orderless=) and display extra information for each one of them (=marginalia=), all that using the Emacs default completion system and UI, which is not up to my taste, so let's get the main package of this section.

*** Completion UI
I like to have a vertical and more dynamic completion UI. Here is where =selectrum= comes in play. So let's install it.

First add =selectrum= itself to =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! selectrum)
#+end_src

And set it up with ~use-packages!~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! selectrum
  :hook (doom-first-input . selectrum-mode)
  :init
  (setq selectrum-display-action nil
        selectrum-num-candidates-displayed 15
        selectrum-extend-current-candidate-highlight t)
  (unless (featurep! +orderless)
    (setq completion-styles '(substring partial-completion)))
  :config
  (setq selectrum-fix-vertical-window-height 17
        selectrum-max-window-height 17)

  (map!
   :g "C-s-r" #'selectrum-repeat
   (:map selectrum-minibuffer-map
    :geni "M-RET" #'selectrum-submit-exact-input
    :geni "C-j"   #'selectrum-next-candidate
    :geni "C-S-j" #'selectrum-next-page
    :geni "C-s-j" #'selectrum-goto-end
    :geni "C-k"   #'selectrum-previous-candidate
    :geni "C-S-k" #'selectrum-previous-page
    :geni "C-s-k" #'selectrum-goto-beginning)))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-selectrum-refresh-on-cycle-a (&rest _)
  :after 'marginalia-cycle
  (when (bound-and-true-p selectrum-mode) (selectrum-exhibit)))
#+end_src

*** Contextual Menu
The next package is a kind of gem I read about. It will allow you to select different actions on a completion candidate based on its context. This package is =embark=. And again, let's start with =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! embark)
(package! embark-consult)
#+end_src

Now we can configure =embark= with ~use-package!~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! embark
  :defer t
  :init
  (setq embark-action-indicator #'my-embark-which-key-action-indicator
        embark-become-indicator embark-action-indicator)
  (map!
    :g "C-s-e" #'embark-act
    (:map minibuffer-local-completion-map
          "C-c C-o" #'embark-export)
    (:map embark-file-map
          :desc "Open Dired on target" :g "j" #'ffap-dired
          :desc "Open target with sudo" :g "s" #'sudo-edit
          :desc "Open target with vlf" :g "l" #'vlf)
    (:map embark-file-map
          :desc "Cycle marginalia views" :g "A" #'marginalia-cycle)))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-embark-which-key-action-indicator (map)
  "Helper function to display the `whichey' help buffer for embark."
  (which-key--show-keymap "Embark" map nil nil 'no-paging)
  #'which-key--hide-popup-ignore-command)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! embark-consult
  :after (embark consult)
  :hook
  (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src

*** Extra commands
In order to be a full replacement for =ivy= + =counsel=, we need to install =consult=, which comes with a bundle of useful helper commands. Let's start with =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! consult)
#+end_src

Now we need to configure each one of this packages. Let's start with the main =consult= package:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! consult
  :defer t
  :init
  (define-key!
    [remap apropos]                       #'consult-apropos
    [remap bookmark-jump]                 #'consult-bookmark
    [remap command-history]               #'consult-complex-command
    [remap evil-show-marks]               #'consult-mark
    [remap goto-line]                     #'consult-goto-line
    [remap grep]                          #'consult-grep
    [remap imenu]                         #'consult-imenu
    [remap isearch]                       #'consult-isearch
    [remap locate]                        #'consult-locate
    [remap load-theme]                    #'consult-theme
    [remap man]                           #'consult-man
    [remap multi-occur]                   #'consult-multi-occur
    [remap projectile-ripgrep]            #'consult-ripgrep
    [remap recentf-open-files]            #'consult-recent-file
    [remap switch-to-buffer]              #'consult-buffer
    [remap switch-to-buffer-other-window] #'consult-buffer-other-window
    [remap switch-to-buffer-other-frame]  #'consult-buffer-other-frame
    [remap view-register]                 #'consult-register
    [remap yank-pop]                      #'consult-yank-pop)

  (map! (:leader
         :desc "Show mode commands" :n "M-x" #'consult-mode-command

         (:prefix ("s" . "search")
          :desc "Jump to mark globally" :n "R" #'consult-global-mark)

         (:prefix ("f" . "find")
          :desc "Find project file" :n "o" #'consult-find

          (:prefix ("i" . "inside")
           :desc "Find inside file" :n "f" #'consult-lines
           :desc "Find inside file (focus)" :n "F" #'consult-focus-lines)))

        (:map outline-mode-map :localleader :prefix ("s" . "tree/subtree")
         :desc "Search outline"  "o" #'consult-outline))

  :config
  (setq consult-project-root-function #'doom-project-root)
  (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-narrow-key "<")
  (setq consult-line-numbers-widen t)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8))
#+end_src

We just set couple functions that are not default to =consult= and some minor tweaks on its options.

At this point, our configuration is matching the standard =ivy= + =counsel= duo.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-extended-yank-pop-a (&rest _)
  "Interactively select what text to insert from the kill ring."
  :override '+default/yank-pop
  (interactive "P")
  (call-interactively
   (cond ((fboundp 'counsel-yank-pop)    #'counsel-yank-pop)
         ((fboundp 'consult-yank-pop)    #'consult-yank-pop)
         ((fboundp 'helm-show-kill-ring) #'helm-show-kill-ring)
         ((error "No kill-ring search backend available. Enable ivy or helm!")))))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-extended-search-project-a (&optional arg)
  "Conduct a text search in the current project root.

If prefix ARG is set, include ignored/hidden files."
  :override '+default/search-project
  (interactive "P")
  (let* ( ;;  (projectile-project-root nil)
         (disabled-command-function nil)
         (current-prefix-arg (unless (eq arg 'other) arg))
         (default-directory
           (if (eq arg 'other)
               (if-let (projects (projectile-relevant-known-projects))
                   (completing-read "Search project: " projects nil t)
                 (user-error "There are no known projects"))
             default-directory)))
    (call-interactively
     (cond ((featurep! :completion ivy)  #'+ivy/project-search)
           ((featurep! :completion helm) #'+helm/project-search)
           ((fboundp 'consult--grep)     #'my-selectrum-project-search)
           (#'projectile-ripgrep)))))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-extended-search-cwd-a (&optional arg)
  "Conduct a text search in files under the current folder.

If prefix ARG is set, prompt for a directory to search from."
  :override '+default/search-cwd
  (interactive "P")
  (let ((default-directory
          (if arg
              (read-directory-name "Search directory: ")
            default-directory)))
    (call-interactively
     (cond ((featurep! :completion ivy)  #'+ivy/project-search-from-cwd)
           ((featurep! :completion helm) #'+helm/project-search-from-cwd)
           ((fboundp 'consult--grep) #'my-selectrum-project-search-from-cwd)
           (#'rgrep)))))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(cl-defun my-selectrum-file-search (&key query in all-files (recursive t) prompt args)
  "Conduct a file search using ripgrep.

:query STRING
  Determines the initial input to search for.
:in PATH
  Sets what directory to base the search out of. Defaults to the current
  project's root.
:recursive BOOL
  Whether or not to search files recursively from the base directory."
  (declare (indent defun))
  (unless (executable-find "rg")
    (user-error "Couldn't find ripgrep in your PATH"))
  (require 'consult)
  (let* ((this-command 'consult-ripgrep)
         (project-root (or (doom-project-root) default-directory))
         (directory (or in project-root))
         (ripgrep-command (mapconcat #'identity (seq-remove 'null
                                      (append (butlast (split-string consult-ripgrep-command " +"))
                                              (list
                                               (when all-files "-uu")
                                               (unless recursive " --maxdepth 1")
                                               "--hidden"
                                               "-g!.git")
                                              args
                                              '("-e"))) " "))
         (prompt (or prompt
                     (format "%s [%s]: "
                             ripgrep-command
                             (cond ((equal directory default-directory) "./")
                                   ((equal directory project-root) (projectile-project-name))
                                   ((file-relative-name directory project-root))))))
         (query (or query
                    (when (doom-region-active-p)
                      (replace-regexp-in-string
                       "[! |]" (lambda (substr)
                                 (cond ((string= substr " ") "  ")
                                       ((string= substr "|") "\\\\\\\\|")
                                       ((concat "\\\\" substr))))
                       (rxt-quote-pcre (doom-thing-at-point-or-region))))
                    " ")))
    ;; (setq deactivate-mark t)
    (consult--grep prompt ripgrep-command directory query)))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-selectrum-project-search (&optional arg initial-query directory)
  "Performs a live project search from the project root using ripgrep.
If ARG (universal argument), include all files, even hidden or compressed ones,
in the search."
  (interactive "P")
  (my-selectrum-file-search
    :prompt (format "Find text on project files \[%s\]"
                    (if (or (and (not directory) (doom-project-root))
                            (and directory (equal directory (doom-project-root))))
                        (projectile-project-name)
                      (file-relative-name (or directory (doom-project-root) default-directory))))
    :query initial-query
    :in directory
    :all-files arg))
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-selectrum-project-search-from-cwd (&optional arg initial-query)
  "Performs a project search recursively from the current directory.
If ARG (universal argument), include all files, even hidden or compressed ones."
  (interactive "P")
  (my-selectrum-project-search arg initial-query default-directory))
#+end_src

*** Change Doom's behavior
By default, Doom comes with all its configuration tailored for =ivy= or =helm=, this means that some packages will need some help from us to work nicely with =selectrum= and friends.c

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-spell-correct-a ()
  "Correct spelling of word at point."
  :override '+spell/correct
  (interactive)
  ;; spell-fu fails to initialize correctly if it can't find aspell or a similar
  ;; program. We want to signal the error, not tell the user that every word is
  ;; spelled correctly.
  (unless (;; This is what spell-fu uses to check for the aspell executable
           or (and ispell-really-aspell ispell-program-name)
           (executable-find "aspell"))
    (user-error "Aspell is required for spell checking"))

  (ispell-set-spellchecker-params)
  (save-current-buffer
    (ispell-accept-buffer-local-defs))
  (cl-destructuring-bind (start . end)
      (or (bounds-of-thing-at-point 'word)
          (user-error "No word at point"))
    (let ((word (thing-at-point 'word t))
          (orig-pt (point))
          poss ispell-filter)
      (ispell-send-string "%\n")
      (ispell-send-string (concat "^" word "\n"))
      (while (progn (accept-process-output ispell-process)
                    (not (string= "" (car ispell-filter)))))
      ;; Remove leading empty element
      (setq ispell-filter (cdr ispell-filter))
      ;; ispell process should return something after word is sent. Tag word as
      ;; valid (i.e., skip) otherwise
      (unless ispell-filter
        (setq ispell-filter '(*)))
      (when (consp ispell-filter)
        (setq poss (ispell-parse-output (car ispell-filter))))
      (cond
       ((or (eq poss t) (stringp poss))
        ;; don't correct word
        (message "%s is correct" (funcall ispell-format-word-function word))
        t)
       ((null poss)
        ;; ispell error
        (error "Ispell: error in Ispell process"))
       (t
        ;; The word is incorrect, we have to propose a replacement.
        (setq res (funcall +spell-correct-interface (nth 2 poss) word))
        ;; Some interfaces actually eat 'C-g' so it's impossible to stop rapid
        ;; mode. So when interface returns nil we treat it as a stop.
        (unless res (setq res (cons 'break word)))
        (cond
         ((stringp res)
          (+spell--correct res poss word orig-pt start end))
         ((let ((cmd (car res))
                (wrd (cdr res)))
            (unless (or (eq cmd 'skip)
                        (eq cmd 'break)
                        (eq cmd 'stop))
              (+spell--correct cmd poss wrd orig-pt start end)
              (unless (string-equal wrd word)
                (+spell--correct wrd poss word orig-pt start end))))))
        (ispell-pdict-save t))))))

#+end_src

The first module we have to change, is /workspaces/.

** TODO Workspaces
There is one module on Doom that don't play nice with =selectrum=: /Workspace/ (based on =persp-mode=).

The problem with /Workspace/ is that its base package is buggy, and requires Doom to do a lot of work in order to get it more or less working.

Instead of trying to replace functions from this package, we will disable the module entirely and add =perspective.el=, which is the package =persp-mode= forked.

We already disable the module on our =init.el= by commenting the line referent to it (you can check it on the [[Prologue]] section). But there is another package Doom uses to synchronize its workspaces that conflicts with =perspective.el=: =treemacs-persp=.

Since we will install another package to sync with =treemacs=, we can disable this one on our =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! treemacs-persp :disable t)
#+end_src

The next step is to add the three packages we will use to replace =persp-mode=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! perspective)
(package! persp-projectile)
(package! treemacs-perspective)
#+end_src

With that we can start configuring these packages with =use-package!=. Let's begin with the main package since it is the most complex:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! perspective
#+end_src

Add the trigger to let Doom knows when to actually load the package:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  :hook (doom-first-input . persp-mode)
#+end_src

=perspective.el= allows different styles of sorting for its workspaces, the one that is closer to what Doom offers by default is to sort them by the order we create them.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  :custom
  (persp-sort 'created)
#+end_src

It still print the perspectives on the inverse order that we want, but we will fix that behavior when we implement the /workspace tab bar/ later.

And since we will implement the default Doom /workspace tab bar/, we don't need =perspective.el= to print its perspective on the modeline:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (persp-show-modestring nil)
#+end_src

This change is something particular to my taste. Doom set the name of the workspace that never closes to "main". Although this is a good name, I would rater something even more generic:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (persp-initial-frame-name "default")
#+end_src

With these configurations we can turn =perspective.el= on when Doom loads the module:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  :config
  (persp-mode 1)
#+end_src

As mentioned before, Doom has the /workspaces/ module tight coupled with other ares. The problem we have is =persp-mode=, uses the same mode name of =perspective.el=, and when some Doom configuration tries to retrieve an information from /workspaces/, it can't detect we disabled the module.

To workaround this, we need to define or alias some functions that Doom expects to be available when /workspaces/ is on:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun persp-parameter (param-name &optional persp)
  (alist-get param-name (persp-local-variables (or persp (persp-curr)))))

;;;###autoload
(defalias 'get-current-persp #'persp-current-name)

;;;###autoload
(defalias 'safe-persp-name (lambda (&rest _) (persp-current-name)))
#+end_src

Don't forget to close the =use-package!= sexp:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
) ;; use-package! perspective
#+end_src

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun project-bookmark-alist ()
  (seq-filter
   (lambda (bm)
     (when-let ((proj-root (doom-project-root)))
       (not (cl-search ".." (file-relative-name (bookmark-get-filename bm) proj-root)))))
   bookmark-alist))


;;;###autoload
(defun project-bookmark-completing-read (prompt &optional default)
  "Prompting with PROMPT, read a bookmark name in completion.

PROMPT will get a \": \" stuck on the end no matter what, so you probably don't
want to include one yourself. Optional arg DEFAULT is a string to return if the
user input is empty. If DEFAULT is nil then return empty string for empty
input."
  (bookmark-maybe-load-default-file)    ; paranoia
  (if (listp last-nonmenu-event)
      (bookmark-menu-popup-paned-menu t prompt
                                      (if bookmark-sort-flag
                                          (sort (bookmark-all-names)
                                                'string-lessp)
                                        (bookmark-all-names)))
    (let* ((completion-ignore-case bookmark-completion-ignore-case)
           (default (unless (equal "" default) default))
           (prompt (concat prompt (if default
                                      (format " (%s): " default)
                                    ": "))))
      (completing-read prompt
                       (lambda (string pred action)
                         (if (eq action 'metadata)
                             '(metadata (category . bookmark))
                           (complete-with-action
                            action
                            (project-bookmar-alist)
                            string
                            pred)))
                       nil 0 nil 'bookmark-history default))))


;;;###autoload
(defun project-bookmark-jump (bookmark &optional display-func)
  "Jump to bookmark BOOKMARK (a point in some file).

You may have a problem using this function if the value of variable
`bookmark-alist' is nil. If that happens, you need to load in some bookmarks.
See help on function `bookmark-load' for more about this.

If the file pointed to by BOOKMARK no longer exists, you will be asked if you
wish to give the bookmark a new location, and `bookmark-jump' will then jump to
the new location, as well as recording it in place of the old one in the
permanent bookmark record.

BOOKMARK is usually a bookmark name (a string).  It can also be a
bookmark record, but this is usually only done by programmatic callers.

If DISPLAY-FUNC is non-nil, it is a function to invoke to display the
bookmark.  It defaults to `pop-to-buffer-same-window'.  A typical value for
DISPLAY-FUNC would be `switch-to-buffer-other-window'."
  (interactive
   (list (project-bookmark-completing-read "Jump to bookmark"
                                           bookmark-current-bookmark)))
  (unless bookmark
    (error "No bookmark specified"))
  (bookmark-maybe-historicize-string bookmark)
  ;; Don't use `switch-to-buffer' because it would let the
  ;; window-point override the bookmark's point when
  ;; `switch-to-buffer-preserve-window-point' is non-nil.
  (bookmark--jump-via bookmark (or display-func 'pop-to-buffer-same-window)))
#+end_src

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun project-recentf-list ()
  (seq-filter
   (lambda (fname)
     (when-let ((proj-root (doom-project-root)))
       (not (cl-search ".." (file-relative-name fname proj-root)))))
   recentf-list))

;;;###autoload
(defun persp-current-real-buffers ()
  "Return a list of names of all living buffers in the current perspective."
  (let ((ignore-rx (persp--make-ignore-buffer-rx)))
    (cl-loop for buf in (persp-current-buffers)
             if (and (doom-real-buffer-p buf)
                     (not (string-match-p ignore-rx (buffer-name buf))))
             collect buf)))

;;;###autoload
(defun persp-current-real-buffer-names ()
  "Return a list of names of all living buffers in the current perspective."
  (let ((ignore-rx (persp--make-ignore-buffer-rx)))
    (cl-loop for buf in (persp-current-buffers)
             if (and (doom-real-buffer-p buf)
                     (not (string-match-p ignore-rx (buffer-name buf))))
             collect (buffer-name buf))))

;;;###autoload
(defun persp-switch-to-real-buffer* (buffer-or-name)
  "Like `switch-to-buffer', restricted to the current perspective.
This respects ido-ignore-buffers, since we automatically add buffer filtering to
ido-mode already (see use of PERSP-SET-IDO-BUFFERS)."
  (interactive
   (list
    (if (or current-prefix-arg (not persp-mode))
        (let ((read-buffer-function nil))
          (read-buffer-to-switch "Switch to buffer"))
      (let* ((candidates (persp-current-real-buffer-names))
             (other (buffer-name (persp-other-buffer))))
        ;; NB: This intentionally calls completing-read instead of
        ;; persp-interactive-completion-function, since it is expected to have
        ;; been replaced by a completion framework.
        (completing-read (format "Switch to buffer%s: "
                                 (if other
                                     (format " (default %s)" other)
                                   ""))
                         candidates
                         nil nil nil nil
                         (buffer-name (persp-other-buffer)))))))
  (let ((buffer (window-normalize-buffer-to-switch-to buffer-or-name)))
    (switch-to-buffer buffer)))
#+end_src


#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun persp-consult-buffer ()
  "Enhanced `switch-to-buffer' command with support for perspectives.

The command supports recent files, bookmarks, views and project files as virtual
buffers. Buffers are previewed. Furthermore narrowing to buffers (b), files (f),
bookmarks (m), views (v) and project files (p) is supported via the
corresponding keys. In order to determine the project-specific files and
buffers, the `consult-project-root-function' is used. The list of available
views is obtained by calling `consult-view-list-function'."
  (interactive)
  (require 'consult)
  (persp-consult--buffer #'switch-to-buffer
                         #'find-file
                         #'bookmark-jump))

(defun persp-consult--buffer (open-buffer open-file open-bookmark)
  "Backend implementation of `consult-buffer'.

Depending on the selected item OPEN-BUFFER, OPEN-FILE or OPEN-BOOKMARK will be
used to display the item."
  (let* ((curr-buf (current-buffer))
         (all-bufs (append (delq curr-buf (persp-current-real-buffers)) (list curr-buf)))
         (buf-file-hash (let ((ht (make-hash-table :test #'equal :size (length all-bufs))))
                          (dolist (buf all-bufs ht)
                            (when-let (file (buffer-file-name buf))
                              (puthash file t ht)))))
         (buf-filter (consult--regexp-filter consult-buffer-filter))
         (bufs (mapcar (lambda (x)
                         (let ((name (buffer-name x)))
                           (consult--buffer-candidate
                            (if (string-match-p buf-filter name) ?h ?b)
                            name 'consult-buffer)))
                       all-bufs))
         (views (when consult-view-list-function
                  (mapcar (lambda (x)
                            (consult--buffer-candidate ?v x 'consult-view))
                          (funcall consult-view-list-function))))
         (bookmarks (progn
                      (bookmark-maybe-load-default-file)
                      (mapcar (lambda (x)
                                (consult--buffer-candidate ?m (car x) 'consult-bookmark))
                              (project-bookmark-alist))))
         (all-files (seq-remove (lambda (x) (gethash x buf-file-hash)) (project-recentf-list)))
         (files (mapcar (lambda (x)
                          (consult--buffer-candidate ?f (abbreviate-file-name x) 'consult-file))
                        all-files))
         (proj-root (and consult-project-root-function (funcall consult-project-root-function)))
         (proj-bufs (when proj-root
                      (mapcar (lambda (x)
                                (consult--buffer-candidate ?p (buffer-name x) 'consult-buffer))
                              (seq-filter (lambda (x)
                                            (when-let (file (buffer-file-name x))
                                              (string-prefix-p proj-root file)))
                                          all-bufs))))
         (proj-files (when proj-root
                       (let ((len (length proj-root))
                             (hidden-root (propertize proj-root 'invisible t)))
                         (mapcar (lambda (x)
                                   (consult--buffer-candidate
                                    ?q
                                    (concat hidden-root (substring x len))
                                    'consult-file))
                                 (seq-filter (lambda (x) (string-prefix-p proj-root x)) all-files)))))
         (selected
          (consult--read
           "Switch to: " (append bufs files proj-bufs proj-files views bookmarks)
           :history 'consult--buffer-history
           :sort nil
           :predicate
           (lambda (cand)
             (let ((type (- (aref cand 0) consult--tofu-char)))
               (when (= type ?q) (setq type ?p)) ;; q=project files
               (if (eq consult--narrow 32) ;; narrowed to hidden buffers
                   (= type ?h)
                 (and
                  (/= type ?h) ;; non-hidden buffers
                  (or (not consult--narrow) ;; narrowed
                      (= type consult--narrow))))))
           :narrow `((32 . "Hidden")
                     (?b . "Buffer")
                     (?f . "File")
                     (?m . "Bookmark")
                     ,@(when proj-root '((?p . "Project")))
                     ,@(when consult-view-list-function '((?v . "View"))))
           :category 'consult-buffer
           :lookup
           (lambda (_ candidates cand)
             (if (member cand candidates)
                 (cons (pcase-exhaustive (- (aref cand 0) consult--tofu-char)
                         (?b open-buffer)
                         (?h open-buffer)
                         (?m open-bookmark)
                         (?v consult-view-open-function)
                         (?p open-buffer)
                         (?q open-file)
                         (?f open-file))
                       (substring cand 1))
               ;; When candidate is not found in the alist,
               ;; default to creating a new buffer.
               (and (not (string-blank-p cand)) (cons open-buffer cand))))
           :preview
           (lambda (cand restore)
             (cond
              (restore)
              ;; In order to avoid slowness and unnecessary complexity, we
              ;; only preview buffers. Loading recent files, bookmarks or
              ;; views can result in expensive operations.
              ((and (or (eq (car cand) #'switch-to-buffer)
                        (eq (car cand) #'switch-to-buffer-other-window))
                    (get-buffer (cdr cand)))
               (funcall (car cand) (cdr cand) 'norecord)))))))
    (when selected (funcall (car selected) (cdr selected)))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader
      :desc "Switch buffer" :nvm "," #'persp-consult-buffer
      :desc "Switch to any buffer" :nvm "<" #'consult-buffer)
#+end_src


Now we can install the =projectile= extension for =perspective.el=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! persp-projectile :after (projectile perspective))
#+end_src

And the one for =treemacs=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! treemacs-perspective :after (treemacs perspective)
#+end_src

The =treemacs= integration, also needs some tweaks to functions and hooks that Doom installs in order to guarantee a better behavior from =treemacs= and =persp-mode=.

Once Doom loads the =treemacs= package, we set its scope to ~'Perspectives~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  :config
  (treemacs-set-scope-type 'Perspectives)
#+end_src

Next, we need to change the ~treemacs--on-scope-kill~ function signature. =persp-mode= calls all hooks from ~persp-killed-hook~ with the current perspective as an argument. =perspective.el= changed this behavior to not send any information when calling hooks.

The easiest way to fix this is to create a thin wrapper function for ~treemacs--on-scope-kill~ that will call the correct function passing the result of ~(persp-curr)~ as an argument:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (defalias 'treemacs--new-on-scope-kill
    (lambda () (treemacs--on-scope-kill (persp-curr))))
#+end_src

Then, we can swap the functions on the ~persp-killed-hook~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (remove-hook 'persp-killed-hook #'treemacs--on-scope-kill)
  (add-hook 'persp-killed-hook #'treemacs--new-on-scope-kill)
#+end_src

And finish it by closing the sexp for ~use-package!~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  )
#+end_src

The configuration we have so far will get =perspective.el= working, but not as conveniently as the standard feature on Doom. To achieve the whole functionality, there are two changes we still needs: Dashboard integration and keybindings.

As with other keybindings in my configuration, I will get new functions to live on an /autoload/ file, and call them on the mapping.

The main idea is to mimic Doom's keybindings, so let's look what binds are available for workspaces:

| Action                        | Keybinding  |
|-------------------------------+-------------|
| Display tab bar               | =SPC TAB TAB= |
| Switch workspace              | =SPC TAB .=   |
| Switch to N^{th} workspace       | =SPC TAB= /N/   |
| Switch to final workspace     | =SPC TAB 0=   |
| Switch to last used workspace | =SPC TAB `=   |
| Previous workspace            | =SPC TAB [=   |
| Next workspace                | =SPC TAB ]=   |
| New workspace                 | =SPC TAB n=   |
| Rename workspace              | =SPC TAB r=   |
| Delete this workspace         | =SPC TAB d=   |
| Delete session                | =SPC TAB x=   |
| Delete session and quit       | =SPC TAB X=   |
| Save session to file          | =SPC TAB s=   |
| Load session from file        | =SPC TAB l=   |
| Restore last session          | =SPC TAB R=   |

The next sections will cover each one of these commands, but before we begin, let's prepare our mapping functions:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! (:leader
      (:prefix ("TAB" . "workspace")
#+end_src

Now we can start with the /Display tab bar/ binding, since it is the foundation of Doom's workspace system.

*** Display tab bar
We know Doom uses two special font faces to draw the workspace tab bar (~+workspace-tab-selected-face~ and ~+workspace-tab-face~), but we removed the =workspace= module from our =init.el=. To keep our configuration as close to Doom as possible we need to redefine these faces. Let's use our /autoload/ file =autoload/workspace.el=:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defface +workspace-tab-selected-face '((t (:inherit highlight)))
  "The face for selected tabs displayed by `+workspace/display'"
  :group 'persp-mode)


;;;###autoload
(defface +workspace-tab-face '((t (:inherit default)))
  "The face for selected tabs displayed by `+workspace/display'"
  :group 'persp-mode)
#+end_src

With the faces defined, we can create a helper function to build the tab bar string using a propertized string so we can simply use it when we need it:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace--tabline (&optional names)
  "Returns the given NAMES list as a propertied string representing each name as a
tab for the current workspace session. If an item on the NAMES list matches the
current workspace name, it will represent this item as a selected item."
  (let ((names (or names (reverse (persp-names))))
        (current-name (persp-current-name)))
    (mapconcat
     #'identity
     (cl-loop for name in names
              for i to (length names)
              collect
              (propertize (format " [%d] %s " (1+ i) name)
                          'face (if (equal current-name name)
                                    '+workspace-tab-selected-face
                                  '+workspace-tab-face)))
     " ")))
#+end_src

Notice that we use ~reverse~ when we call ~(persp-names)~. This is to fix the order of tabs that Doom uses.

This helper function allows us to build the interactive function we need:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/display ()
  "Display a list of workspaces (like tabs) in the echo area."
  (interactive)
  (when (bound-and-true-p persp-mode)
    (let (message-log-max)
      (message "%s" (+workspace--tabline)))))
#+end_src

And we can simply bind it to our shortcut key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Display tab bar"           "TAB" #'+workspace/display
#+end_src

*** Switch workspace
The =persp-projectile= package will take care of creating a new workspace for each project we open, but we still need to switch to those workspaces, so let's take care of the /Switch workspace/ binding.

Let's list the requirements for such function:

- This function needs to be interactive, and if I call it with =M-x=, it should request the name of the workspace I want to switch to;
- I can refer to a workspace when calling this function in two ways:
  + Passing a string representing the workspace name;
  + Passing a number representing the 1-based index for the workspace on the /workspace tab bar/;
- If I pass a negative number to the function, it should get the workspace from end to start (e.g. a =-3= on a =10= workspaces session would represent workspace =8=);
- If an error happens, we should warn the user;
- When the switch is complete, we should display the /workspace tab bar/;

And here is the implementation for such function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/switch-to (index &optional auto-create-p)
  "Switch to a workspace at a given INDEX. A negative number will start from the
end of the workspace list."
  (interactive
   (let ((last-used-workspace (+workspace-last-name)))
     (list (completing-read "Switch to workspace: "
                            (persp-names)            ;; lis t
                            nil                      ;; filter
                            (not current-prefix-arg) ;; required
                            nil                      ;; initial input
                            nil                      ;; history
                            last-used-workspace))))  ;; default value
  (when (bound-and-true-p persp-mode)
    (condition-case err
        (let ((target (+workspace-name-from-reference index))
              (old-name (persp-current-name)))
          (unless target
            (if (numberp index)
                (+workspace-error "No workspace on index #%s" (1+ index))
              (+workspace-error "Invalid workspace '%s'" index)))
          (if (equal target old-name)
              (+workspace-warn "Already in %s" old-name)
            (+workspace-switch target (or current-prefix-arg auto-create-p))
            (+workspace/display)))
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

If you analyze this function, you'll realize we don't have some of the functions used here. They are:

- ~+workspace-last-name~ to get the name of the last used workspace;
- ~+workspace-name-from-reference~ to get a workspace name from a reference variable;
- ~+workspace-switch~ to call the lower level API to switch the workspace;
- ~+workspace-error~ called when we need to present an error to the user;
- ~+workspace-warn~ called when we need to present a less problematic error to the user;
- ~+workspace-internal-error~ when we find a failure on the internal APIs of =perspective.el=;

We can start with the last workspace name:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-last-name ()
  (when-let ((last-used-persp (persp-last)))
    (persp-name last-used-persp)))
#+end_src

Then we can add the function to resolve a workspace name from any type of reference:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-name-from-reference (ref)
  "Returns the name of a workspace referenced by REF.

REF can be a perspective object, a string name, a string number, a positive
number, or a negative number. How it retrieves the workspace name depends on the
value of REF:

Perspective object - it access the `CL-X->name' from the object;

String name - return the same value if a workspace with that name exists;

String number - parse the number and get the workspace name from the index
  representing the parsed number;

Positive number - get the workspace name from the index representing the giving
  number;

Negative number - Access the workspace index from the end to the start too
  retrieve the correct workspace;

If REF does not match a current workspace in any way, it returns nil."
  (cond ((perspective-p ref) (persp-name ref))
        ((numberp ref) (+workspace-name-from-index ref t))
        ((stringp ref) (cond ((+workspace-exists-p ref) ref)
                             ((string-match-p "^[0-9]+$" ref) (+workspace-name-from-index (string-to-number ref)
                                                                                          t))))))
#+end_src

This last function needs another helper one, to make sure it returns the correct name for a session on a given index:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace-name-from-index (index &optional noerror)
  "Return the workspace name on INDEX.

This function throw an error if there is no workspace on INDEX. If you pass a
non-nil value to NOERROR, it will return nil when it can't find a workspace.

When INDEX is negative, it access the workspace on the reverse order (e.g. on a
4 workspaces session, -1 access the workspace on index 3)."
  (or (when-let ((is-number (numberp index))
                 (names (reverse (persp-names)))
                 (len (length names))
                 (index (if (< index 0) (+ len index) index))
                 (inbounds (and (>= index 0) (< index len))))
        (nth index names))
      (unless noerror
        (+workspace-error "There is no workspace on index #%s!" index))))
#+end_src

And then we can add the low-level API:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace-switch (name &optional auto-create-p)
  "Switch to another workspace named NAME (a string).

If AUTO-CREATE-P is non-nil, create the workspace if it doesn't exist, otherwise
throws an error."
  (unless (+workspace-exists-p name)
    (if auto-create-p
        (+workspace-new name)
      (+workspace-error "%s is not an available workspace" name)))
  (let ((old-name (persp-current-name)))
    (unless (equal old-name name)
      (persp-switch name))
    (equal (persp-current-name) name)))
#+end_src

This function can brings an existent workspace to the front, or create a new workspace if the given name does not exist and the ~auto-create-p~ flag is a non-nil value.

In this function, there are three functions we still don't have on our configuration:

- ~+workspace-exists-p~ to check if a workspace with the given name exists;
- ~+workspace-new~ to call actual /new perspective/ function;
- ~+workspace-error~ called when we need to present an error to the user;

Let's start with the ~+workspace-exists-p~ function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-exists-p (name)
  "Returns t if NAME is the name of an existing workspace."
  (member name (persp-names)))
#+end_src

Then, we can implement the ~workspace-new~ function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-new (name)
  "Create a new workspace named NAME. If one already exists, return nil.
otherwise return t on success, nil otherwise."
  (when (+workspace--protected-p name)
    (+workspace-error "Can't create a new '%s' workspace" name))
  (when (+workspace-exists-p name)
    (+workspace-error "A workspace named '%s' already exists" name))
  (persp-new name))
#+end_src

The ~+workspace-new~ function have to block the creation of a workspace if the given name is the one used by the main workspace, or if it is the same used on the auto-save feature. These workspace names are what we consider /protected/ names. So let's create a function to check it:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace--protected-p (name)
  "Return non nil if the given NAME is the default initial
workspace name."
  (or (equal name +workspaces-main)
      (equal name +workspaces-auto-save-identifier)))
#+end_src

Let's also define those two variables in case we just want to change them later:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defvaralias #'+workspaces-main #'persp-initial-frame-name)


;;;###autoload
(defvar +workspaces-auto-save-identifier "autosave"
  "Identifier used to auto-save the workspace session.")
#+end_src

Now we need to define our workspaces messaging API. To stay in parity with Doom, we need display the tab bar on the minibuffer, and then a message on its side with the severity of the message color coded.

Since we already have a function to display the tabs for us, lets use that function to build a /message body/ for our API:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace--message-body (text &optional type)
  "Returns a propertied string representing a workspace
message.

A workspace message consist of a 'tab line' representation of the workspace
session, with the given TEXT concatenated after it.

The text color changes depending of TYPE passed. If we omit the TYPE, the
function assumes this message is an 'info message.

We associate the message color to the respective font faces, which are:

- 'info
- 'success
- 'warn
- 'error

The only TYPE that does not have a direct font face representation is 'info,
which uses the `font-lock-comment-face' font face."
  (concat (+workspace--tabline)
          (propertize " | " 'face 'font-lock-comment-face)
          (propertize (format "%s" text)
                      'face (pcase type
                              ('error 'error)
                              ('warn 'warning)
                              ('success 'success)
                              ('info 'font-lock-comment-face)
                              (_ 'font-lock-comment-face)))))
#+end_src

With this last function we can implement a generic message function that we can associate to the right calls later:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace-message (text &optional type)
  "Displays the given TEXT message on the echo area, formatted as a workspace
message (see `+workspace--message-body' for details on the formatting) of the
given TYPE. When type is 'error, if thee INTERNAL argument is a non-nil value,
the message will use the `persp-error' function print it, and when it is nil, it
uses the `error' function. Otherwise, it uses the normal `message' function."
  (cond ((eq type 'error) (error text))
        ((eq type 'user-error) (user-error text))
        ((eq type 'internal-error) (persp-error text))
        (t (message "%s" (+workspace--message-body text type)))))
#+end_src

And now we can define all the /end functions/ for the messaging API.

All these functions have the same pattern. Instead of us defining each one of them, we can loop through the list of possible message types, and create a function for each one:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(mapc (lambda (type)
        (defalias (intern (format "+workspace-%s" type))
          (lambda (text &rest args)
            (+workspace-message (apply 'format (cons text args)) (intern type)))
          (format "Wrapper function around `+workspace-message' with the arg TYPE set to '%s." type)))
      '("info" "success" "warn" "error" "user-error" "internal-error"))
#+end_src

With all the functions necessary to switch between workspaces, I can bind it to their correct key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Switch workspace"          "."   #'+workspace/switch-to
#+end_src

*** Switch to N^{th} workspace
Doom allows you to switch workspaces by their index numbers, and since we already have the main function to do the switch, we can just create the others.

As  with the message API, the /switch to workspace N/ is repetitive, and we can automate the creation of every one of these functions:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(dotimes (i 9)
  (defalias (intern (format "+workspace/switch-to-%d" i))
    (lambda () (interactive) (+workspace/switch-to i))
    (format
     "Thin wrapper around `+workspace/switch-to' function where we pass #%d as the INDEX parameter."
     (1+ i))))
#+end_src

This will create 9 functions to switch to their respective workspace, so let's bind them:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Switch to 1st workspace"   "1"   #'+workspace/switch-to-0
      :desc "Switch to 2nd workspace"   "2"   #'+workspace/switch-to-1
      :desc "Switch to 3rd workspace"   "3"   #'+workspace/switch-to-2
      :desc "Switch to 4th workspace"   "4"   #'+workspace/switch-to-3
      :desc "Switch to 5th workspace"   "5"   #'+workspace/switch-to-4
      :desc "Switch to 6th workspace"   "6"   #'+workspace/switch-to-5
      :desc "Switch to 7th workspace"   "7"   #'+workspace/switch-to-6
      :desc "Switch to 8th workspace"   "8"   #'+workspace/switch-to-7
      :desc "Switch to 9th workspace"   "9"   #'+workspace/switch-to-8
#+end_src

*** Switch to final workspace
Doom also provides a shortcut to get to the last opened workspace (last in the sense of order we created them):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/switch-to-final ()
  "Switch to the final workspace in open workspaces."
  (interactive)
  (+workspace/switch-to (car (persp-names))))
#+end_src

Now we just need to bind this function:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Switch to final workspace" "0"   #'+workspace/switch-to-final
#+end_src

*** Switch to last used workspace
The next binding is the /Switch to last workspace/, which luckily has a function defined on =perspective.el= for it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Switch to last used workspace"  "`"   #'persp-switch-last
#+end_src

*** Previous and next workspace
I'm bundling these two commands together because usually in emacs, you have a function that move to any direction, and then you define different functions for different directions that just call the /move/ function with different parameters.

Let's create our /cycle/ function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/cycle (n)
  "Cycle n workspaces to the right (default) or left."
  (interactive (list 1))
  (when (bound-and-true-p persp-mode)
    (let ((current-name (persp-current-name)))
      (condition-case-unless-debug err
          (let* ((persps (reverse (persp-names)))
                 (perspc (length persps))
                 (index (cl-position current-name persps)))
            (when (= perspc 1)
              (+workspace-user-error "No other workspaces"))
            (+workspace/switch-to (% (+ index n perspc) perspc))
            (unless (called-interactively-p 'interactive)
              (+workspace/display)))
        (t (minibuffer-message "%s"
                             (+workspace--message-body
                              (error-message-string err)
                              'error)))))))
#+end_src

Then, we just need to create a function to move to the previous workspace:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/switch-previous ()  (interactive) (+workspace/cycle -1))
#+end_src

And one for next one:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/switch-next () (interactive) (+workspace/cycle +1))
#+end_src

Then, we can bind both functions to their proper keys:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Previous workspace"        "["   #'+workspace/switch-previous
      :desc "Next workspace"            "]"   #'+workspace/switch-next
#+end_src

*** New workspace
On the sequence, we have the /New workspace/. We already created a helper low-level function to spun new workspaces, now we need a command to call that function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/new (&optional name)
  "Create a new blank workspace named NAME."
  (interactive
   (list (when current-prefix-arg
           (read-from-minibuffer "Name for the new workspace: "))))
  (when (bound-and-true-p persp-mode)
    (unless name
      (setq name (format "Unnamed %s" (+workspace--generate-id))))
    (condition-case err
        (cond ((+workspace-exists-p name) (+workspace-user-error "%s already exists" name))
              (t (+workspace-switch name t)
                 (+workspace/display)))
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

Notice how we use the ~auto-create-p~ functionality on the ~+workspace-switch~ function. Also, you might have noticed we use a helper function to get a sequential number when we don't provide a name to the new workspace, and we didn't implement it yet, so let's do it now:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace--generate-id ()
  "Returns the next sequential number that a new perspective
could use on its name."
  (or (cl-loop for name in (persp-names)
               when (string-match-p "^Unnamed \\([0-9]+\\)$" name)
               maximize (string-to-number (substring name
                                                     (match-beginning 1)
                                                     (match-end 1))) into max
               finally return (if max (1+ max)))
      1))
#+end_src

This function will iterate over all workspaces and if it finds one called =Unnamed N=, =N= becomes the maximum number found. In the end, it returns the maximum number plus one.

Now, we just need to bind the main function with its keys:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "New workspace"             "n"   #'+workspace/new
#+end_src

*** Rename workspace
Going through our list of commands, we need to provide a way for us to rename a giving workspace, specially if we create an empty and unnamed workspace.

Let's start with the command function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/rename (new-name)
  "Rename the current workspace."
  (interactive (list (read-from-minibuffer "New workspace name: ")))
  (when (bound-and-true-p persp-mode)
    (condition-case-unless-debug err
        (let* ((current (persp-current-name))
               (current (if current-prefix-arg
                            (completing-read (format "Select a workspace to rename (default: %s): " current)
                                             (persp-names)           ;; list
                                             (lambda (ws-name)       ;; filter
                                               (not (string= ws-name +workspaces-main)))
                                             t                       ;; required
                                             nil                     ;; initial input
                                             nil                     ;; history
                                             current)                ;; default value
                          current))
               (old-name (+workspace-rename current new-name)))
          (unless old-name
            (+workspace-error "Failed to rename %s" current))
          (+workspace-success (format "Renamed '%s'->'%s'" old-name new-name)))
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

Pretty straightforward, but we still need the low-level function that actually renames the workspace:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-rename (name new-name)
  "Rename the current workspace named NAME to NEW-NAME. Returns old name on
success, nil otherwise."
  (cond ((+workspace--protected-p name) (+workspace-error "Can't rename `%s' workspace" name))
        ((not (+workspace-get name)) (+workspace-error "Perspective `%s' does not exists" name))
        ((+workspace-get new-name) (+workspace-error "Perspective `%s' already exists" new-name))
        (t (progn
             (persp-rename new-name)
             name))))
#+end_src

This function do 3 validations on the given arguments:

1. Is the new name one of the protected names?
   /Should fail if yes/;
2. Is there a real workspace with the given name?
   /Should fail if no/;
3. Is there a real workspace with the new name?
   /Should fail if yes/;

And to make these validations we still need a function we didn't implement yet:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-get (name &optional noerror)
  "return a workspace named name. Unless NOERROR is non-nil, this throws an error
if name doesn't exist."
  (cl-check-type name string)
  (when-let (persp (gethash name (perspectives-hash)))
    (cond ((perspective-p persp) persp)
          ((not noerror) (+workspace-error "There is no workspace called '%s'" name)))))
#+end_src

Now, with all the functions in place, we can bind the main command to its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Rename workspace"               "r"   #'+workspace/rename
#+end_src

*** Delete this workspace
There are two main tasks still missing in our refactor of Doom Workspaces and this next three sections will cover one of them: Delete (or kill if you want).

We will start with the ability to delete a single workspace:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/delete (name)
  "Delete workspace named NAME. If called with C-U, prompts you for the name of
the workspace to delete."
  (interactive
   (let ((current-name (persp-current-name)))
     (list (if current-prefix-arg
               (completing-read (format "Delete workspace (default: %s): " current-name)
                                (persp-names)           ;; list
                                (lambda (ws-name)       ;; filter
                                  (not (string= ws-name +workspaces-main)))
                                t                       ;; required
                                nil                     ;; initial input
                                nil                     ;; history
                                current-name)           ;; default value
             current-name))))
  (when (bound-and-true-p persp-mode)
    (condition-case err
        (+workspace-delete name)
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

The command function simply allows us to select which workspace to delete, or it deletes the current one. As with the other commands, we still need the low-level function that actually deletes the workspace:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-delete (workspace)
  "Delete the workspace denoted by WORKSPACE, which can be the name of a
workspace, its index, or the workspace object itself."
  (let ((ws-name (+workspace-name-from-reference workspace)))
    (unless ws-name
      (+workspace-error "Can't find a workspace for the reference '%s'" workspace))
    (if (+workspace--protected-p ws-name)
        t
      (persp-kill ws-name)
      (+workspace-success (format "Deleted '%s' workspace" workspace))
      (not (+workspace-exists-p ws-name)))))
#+end_src

Now we can bind the command to its proper key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Delete this workspace"          "d"   #'+workspace/delete
#+end_src

*** Delete session
The next command on the /delete/ series is to delete all workspaces.

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/delete-session (&optional interactive)
  "Delete the current session, all workspaces, windows and their buffers."
  (interactive (list t))
  (when (bound-and-true-p persp-mode)
    (condition-case err
        (let ((windows (length (window-list)))
              (persps (length (persp-names)))
              (buffers 0))
          (unless (cl-every #'+workspace-delete (persp-names))
            (+workspace-error "Could not clear session"))
          (+workspace/switch-to +workspaces-main t)
          (setq buffers (doom/kill-all-buffers (buffer-list)))
          (when interactive
            (+workspace-success "Killed %s workspace(s), %s window(s) & %s buffer(s)" persps windows buffers)))
        (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

And since we only used functions we already have implemented, we can bind it to its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Delete session"                 "x"   #'+workspace/delete-session
#+end_src

*** Delete session and quit
On the next sections in this document, we will configure session persistence, and the time when we will save our sessions, is when we kill Emacs. If we delete all sessions, and then quit, the result is that Emacs will save our /empty/ session before quitting. Although we might desire this behavior some times, we also need a way to tell emacs to /discard/ our current session. To achieve this, let's define a variable to use as a flag for saving the session or not:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defvar +workspace--auto-save-session-p t
  "Flag used to determine if Emacs should automatically save the current session
when we quit.")
#+end_src

And now, we can have our last command on the /delete/ category to flag Emacs to not save current session when quitting. This way, if we wants to quit and save the current session, we simply quit Emacs, and if we want to discard the current session, we invoke the /delete session and quit/ command:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/delete-session-and-quit ()
  "Kill emacs without saving anything."
  (interactive)
  (when (bound-and-true-p persp-mode)
    (call-interactively #'+workspace/delete-session)
    (let ((+workspace--auto-save-session-p nil))
      (kill-emacs))))
#+end_src

And since we only used functions we already have implemented, we can bind it to its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Delete session and quit"        "X"   #'+workspace/delete-session-and-quit
#+end_src

*** Save session to file
Our workspace refactor is working as expected, but we still need persistence. =perspective.el= and =persp-mode= behave a bit different on this regard. The former can only save your entire session to file, while the latter saves individual workspaces. For me particularly, is not a big issue, but if you rely on such feature, know that you won't have it with my setup.

With that out of the way, let's jump right into the first command:

#+caption[File]: autoload/workspaces.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/save-session (name)
  "Save the current workspace with the given NAME as its identifier."
  (interactive
   (list (completing-read "Save workspace session to file: "
                          (mapcar
                           (lambda (file)
                             (string-remove-prefix
                              +workspaces-data-file-prefix (file-name-base file)))
                           (file-expand-wildcards (format "%s%s*.dws"
                                                          +workspaces-data-dir
                                                          +workspaces-data-file-prefix))))))
  (when (bound-and-true-p persp-mode)
    (condition-case err
        (if (+workspace-session-save name)
            (+workspace-success (format "'%s' workspace saved" name))
          (+workspace-error (format "Could not save workspace %s" name)))
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

The only part of this function that is worth mentioning is that we show the list of current saved workspaces so we can see what is there when we're choosing a filename.

We still need to code our low level  function to save a workspace:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-session-save (&optional identifier force interactive?)
  "Saves the workspace session to a file named IDENTIFIER located on the
`+workspaces-data-dir' directory. We can load a saved session with
`+workspace-load'.

If we call this function without a IDENTIFIER, we will generate a name using the
current time, and the format \"%Y-%0m-%0d-%0H-%0M\".

If FORCE is non nil, this function will overwrite the session file if it is
already present in the system.

Returns t on success, nil otherwise."
  (unless (file-exists-p +workspaces-data-dir)
    (make-directory +workspaces-data-dir))
  (when-let ((fname (+workspace-resolve-session-file-path identifier))
             (should-save (or (or (not (file-exists-p fname)) force)
                              (yes-or-no-p (format "Overwrite the '%s' session state?" identifier)))))
    (let ((current-prefix-arg t))
      (persp-state-save fname interactive?))
    (file-exists-p fname)))
#+end_src

We will make sure that the most complex part of this function goes to another function to make easy to understand and reusable:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-resolve-session-file-path (&optional name)
  "Returns the full path for a session filename given a NAME identifier.

If we omit the NAME, we will use the current time with the format
\"%Y-%0m-%0d-%0H-%0M\" (see `format-time-string' for information about the
format), if NAME is not a string nor nil, we throw an error."
  (unless (string-or-null-p name)
    (+workspace-error "Invalid name! Argument '%s' is not string or nil" name))
  (expand-file-name (format "%s%s.dws"
                            +workspaces-data-file-prefix
                            (or name (format-time-string "%Y-%0m-%0d-%0H-%0M")))
                    +workspaces-data-dir))
#+end_src

In this function we introduce two new variables that we still didn't define. The ~+workspaces-data-dir~ holds the location of our workspace saved files, and ~+workspaces-data-file-prefix~ holds a common prefix for workspace files so we can filter them easily.

Let's add these variables to our autoload file:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defvar +workspaces-data-dir (concat doom-etc-dir "workspaces/")
  "Directory where we store perspective files.")


;;;###autoload
(defvar +workspaces-data-file-prefix "_workspaces_"
  "The filename prefix of files used to store a workspace session. We will store
these file at `+workspaces-data-dir'.")
#+end_src

And now we can add the command to its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Save session to file"           "s"   #'+workspace/save-session
#+end_src

*** Load session from file
At this point, we can arbitrarily save our sessions to files, but still need a way to load them. Let's create the /load/ command:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/load-session (name)
  "Load a workspace session with identifier NAME."
  (interactive
   (list
    (completing-read "Workspace session to load: "
                     (mapcar
                      (lambda (file)
                        (string-remove-prefix +workspaces-data-file-prefix (file-name-base file)))
                      (file-expand-wildcards (format "%s%s*.dws"
                                                     +workspaces-data-dir
                                                     +workspaces-data-file-prefix)))
                     (lambda (identifier)
                       (not (string= identifier +workspaces-auto-save-identifier)))
                     t)))
  (when (bound-and-true-p persp-mode)
    (condition-case err
        (if (not (+workspace-session-load name))
            (+workspace-error "Could not load workspace session %s" name)
          (+workspace/display))
      (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error))))))
#+end_src

The difference between the /save/ and /load/ commands (besides the obvious), is that when we load, we force the user to complete to a valid load file with the 4^{th} parameter on ~completing-read~.

As usual, lets get our low-level API coded as well:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defun +workspace-session-load (name)
  "Loads a workspace session identified by NAME. Can only retrieve workspace
sessions that were explicitly saved with `+workspace-session-save'.

Returns t if successful, nil otherwise."
  (persp-state-load (+workspace-resolve-session-file-path name))
  (> (length (persp-names)) 0))
#+end_src

And bind this command to its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Load session from file"         "l"   #'+workspace/load-session
#+end_src

*** Restore last session
Now that we save and load our workspace sessions, is time for us to make this process a bit more automated. Just like Doom's behavior, we want Emacs to save our session when it exits, and we want to be able to restore the last auto-saved session.

The first thing we need is a hook function to execute every time Emacs quits:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace-auto-save-h ()
  (when +workspace--auto-save-session-p
    (+workspace-session-save +workspaces-auto-save-identifier t nil)))
#+end_src

And we need a function to restore the last saved session:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/restore-last-session ()
  "Tries to load the 'auto-saved' session from last time we used Emacs."
  (interactive)
  (condition-case err
      (let ((as-file (+workspace-resolve-session-file-path +workspaces-auto-save-identifier)))
        (message "Restoring session...")
        (if (file-exists-p as-file)
            (unless (+workspace-session-load +workspaces-auto-save-identifier)
              (+workspace-error "Failed to restore previous auto-saved session"))
          (+workspace-warn "There is no session previously saved"))
        (message "Session restored. Welcome back."))
    (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error)))))
#+end_src

With the restore command done, we can associate it with its key:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :desc "Restore last session"           "R"   #'+workspace/restore-last-session
#+end_src

Now that we defined all /leader/ keys, we can close our /leader/ mapping:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      )  ;; :prefix ("TAB" . "workspace")
      )  ;; :leader
#+end_src

*** Other shortcuts
Doom also offers nice shortcuts for us to access our workspace. They're all bound to =Meta= plus a number:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
      :ne "C-t"   #'+workspace/new
      :ne "C-S-t" #'+workspace/display
      :ne "M-1"   #'+workspace/switch-to-0
      :ne "M-2"   #'+workspace/switch-to-1
      :ne "M-3"   #'+workspace/switch-to-2
      :ne "M-4"   #'+workspace/switch-to-3
      :ne "M-5"   #'+workspace/switch-to-4
      :ne "M-6"   #'+workspace/switch-to-5
      :ne "M-7"   #'+workspace/switch-to-6
      :ne "M-8"   #'+workspace/switch-to-7
      :ne "M-9"   #'+workspace/switch-to-8
      :ne "M-0"   #'+workspace/switch-to-final
#+end_src

These shortcuts close the majority of workspace binding we may need:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
)  ;; map!
#+end_src

There are couple shortcuts that are not defined with the ~map!~ function, so we can tackle them here:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(define-key! persp-mode-map
  [remap delete-window] #'+workspace/close-window-or-workspace
  [remap evil-window-delete] #'+workspace/close-window-or-workspace)
#+end_src

This will delete the current workspace if closing the last open window. But we still need to implement the target function here:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun +workspace/close-window-or-workspace ()
  "Close the selected window. If it's the last window in the workspace, either
close the workspace (as well as its associated frame, if one exists) and move to
the next."
  (interactive)
  (condition-case err
      (if (cdr (my-tabs-mode-persp-window))
          (tab-line-close-tab)
        (let ((delete-window-fn (if (featurep 'evil)
                                    #'evil-window-delete
                                  #'delete-window))
              (buf (current-buffer)))
          (if (window-dedicated-p)
              (funcall delete-window-fn)
            (let ((current-persp-name (persp-current-name)))
              (cond ((or (+workspace--protected-p current-persp-name)
                         (cdr (doom-visible-windows)))
                     (funcall delete-window-fn))
                    ((cdr (persp-names))
                     (+workspace/delete current-persp-name))
                    ((+workspace-error "Can't delete last workspace")))))))
    (t (minibuffer-message "%s" (+workspace--message-body (error-message-string err) 'error)))))
#+end_src

When we have the feature =workspaces= on our =init.el=, Doom will add an option on its dashboard to allow us to recover the last saved session. Since we disabled that feature, we need to add this option again:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-to-list
 '+doom-dashboard-menu-sections
 '("Reload last session"
   :icon (all-the-icons-octicon "history"
                                :face 'doom-dashboard-menu-title)
   :face (:inherit (doom-dashboard-menu-title bold))
   :action +workspace/restore-last-session))
#+end_src

The only thing remaining on our refactor, is to connect our auto-save function to the hook ~kill-emacs-hook~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-emacs-hook #'+workspace-auto-save-h)
#+end_src

* Writing
Unfortunately, my main job at work is to do mobile development for the Android platform. While Emacs is OK handling Java, Kotlin, and friends, compared to IDEs like IntelliJ and Android Studio, there are way more configuration and adjustments I would need to do on Emacs to get a distance resemblance of those IDEs. Because of this reason, my main usage for Emacs is writing and scripting.

My intention is to do any writing I need, using Org mode. And that is the reason this section of my setup is as big as it can be.

I come up with a directory infrastructure for my writings that will hold all type of text I need to produce:

#+caption: My org directory structure
#+begin_src text :tangle no
   org
  ├──  .archives
  ├──  .attach
  ├──  agenda
  │  ├──  calendars
  │  │  ├──  personal.org
  │  │  └──  work.org
  │  ├──  tasks
  │  │  ├──  someday.org
  │  │  └──  todo.org
  │  ├──  contacts.org
  │  └──  habits.org
  ├──  documents
  ├──  journal
  ├──  notes
  └──  presentations
#+end_src

Most of these directories are straightforward to understand their purpose, but I still want to go through them to document my need.

- =.archives= :: Any Org task archived on my system will end up in this directory. After a while, this directory should be a shadow copy of the root =org= directory, but containing only files with archived tasks;
- =.attach= :: This is the Doom's directory to store attached files;
- =agenda= :: The root folder for task management:
  + =calendars= :: Here is where I will add the events for my calendars. Each calendar I have will have its own file here. These files are not intended to manage my calendars, and I will consider them as /read-only files/. Outside Emacs, I will have process running and synchronizing these files;
  + =tasks= :: Directory to store Org files with tasks. The main file, which I will track on Org Agenda is thee =todo.org=, but I have this extra file called =someday.org= as a dump for tasks I wish to accomplish but are not essentials;
  + =contacts.org= :: The Org file used to record my contacts. I still need to find a good way to synchronize this file with my phone contacts, but this is out of the scope of this document;
  + =habits.org= :: Once I'm ready to try tracking my habits, this is the file I should use;
- =documents= :: This is the dumping ground for any type of document (articles, design architecture, blog posts, wiki entries, etc.). Inside of it, I will have one directory per area (work, home, personal site, etc.);
- =journal= :: I need to have one work journal and one personal journal, but I still don't know how to do this separation effectively. For now, I will have all my journaling stored here;
- =notes= :: My curated notes. All files in this directory have no name (I use UUID as their name), and I can access their content by using the Zettelkasten method on my system;
- =presentations= :: The directory for my presentation projects using =reveal.js=;

Regarding my configuration for Org mode, I will split it into 6 distinct sections, one per usage I will have for Org:

- Prose writing
- Reading or reviewing
- Publishing
- Presenting
- Note Taking
- Time Management

** TODO Requirements
** TODO Common Org configurations
But before we dive in each one of these usages, there are some things I like to configure on Org that will affect all the other areas, so I will start with them here.

The first thing I like to do, is to create some variables pointing to key locations and files on my directory structure:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(unpin! org-mode)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq writeroom-mode-line       t
      +zen-window-divider-size  2
      +zen-text-scale           1)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq org-html-htmlize-output-type 'css
      org-html-head-include-default-style nil
      org-html-doctype "html5"
      org-html-html5-fancy t)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq org-directory (expand-file-name "~/depot/Dropbox/org"))

(defconst my-journal-directory (expand-file-name "journal" org-directory)
  "Path to directory holding all journal files")

(defconst my-docs-directory (expand-file-name "documents" org-directory)
  "Path to directory used to store non specific documents.")

(defconst my-agenda-directory (expand-file-name "agenda" org-directory)
  "Path to the base directory for the agenda system.")

(defconst my-calendars-directory (expand-file-name "calendars" my-agenda-directory)
  "Path to directory used to store calendar files.")

(defconst my-tasks-directory (expand-file-name "tasks" my-agenda-directory)
  "Path to directory used to store task files.")

(defconst my-notes-directory (expand-file-name "notes" org-directory)
  "Path to directory used to store note files.")

(defconst my-presentations-directory (expand-file-name "presentations" org-directory)
  "Path to directory used to store presentation files.")
#+end_src

Notice that we crated these variables before loading anything related to Org. The ~org-directory~ variable needs to have the correct value when Org mode is initializing, and the others are just grouped close to the main Org one.

Now we can wait Org to load to  continue our configuration:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset (cl-loop for i from 1 to 8 collect (intern (format "outline-%d" i))))
(custom-set-faces!
  `(outline-1 :inherit my-headline-1 :weight unspecified :extend unspecified)
  `(outline-2 :inherit my-headline-2 :weight unspecified :extend unspecified)
  `(outline-3 :inherit my-headline-3 :weight unspecified :extend unspecified)
  `(outline-4 :inherit my-headline-4 :weight unspecified :extend unspecified)
  `(outline-5 :inherit my-headline-5 :weight unspecified :extend unspecified)
  `(outline-6 :inherit my-headline-6 :weight unspecified :extend unspecified)
  `(outline-7 :inherit my-headline-7 :weight unspecified :extend unspecified)
  `(outline-8 :inherit my-headline-8 :weight unspecified :extend unspecified))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-org-font-lock-beautify-keywords
  `(("^#\\+TITLE: *"
     (0 (prog1 nil (put-text-property (match-beginning 0) (match-end 0) 'invisible t))))
    ("^\\*+ "
     (0 (prog1 nil (put-text-property (match-beginning 0) (match-end 0) 'invisible t))))
    ("^ *\\([-+*] \\[ \\]\\) "
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "☐ "))))
    ("^ *\\([-+*] \\[-\\]\\) "
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "⊡ "))))
    ("^ *\\([-+*] \\[[xX]\\]\\) "
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "☑ "))))
    ("^ *\\(-\\) \\([^\\[]\\|\\[[^ xX-]\\)"
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "•"))))
    ("^ *\\(\\+\\) \\([^\\[]\\|\\[[^ xX-]\\)"
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "‣"))))
    ("^ *\\(\\*\\) \\([^\\[]\\|\\[[^ xX-]\\)"
     (0 (prog1 nil (compose-region (match-beginning 1) (match-end 1) "⁍")))))
  "This is a list of text elements fontification for Org. It
beautifies title, check-boxes, and list bullets.")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org
#+end_src

I like to /beautify/ Org buffers with some tweaks. First I want header tags to be close to the header text:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-tags-column 0)
#+end_src

Then I like to have some indentation indicating which header level I am:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-startup-indented nil)
#+end_src

I also like to display text formatting as close to WYSIWYG as I can have. This means that if I mark a word as italic, instead of showing =/word/=, I want to display /word/:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-hide-emphasis-markers t
        org-pretty-entities t)
#+end_src

When Org collapse a header, it displays an ellipsis right after the header text. Although this is not "bad", I like to have a better indication of a collapsed header:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-ellipsis "  ")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src


In some documents, I need to write math formulas and Org can render them pretty well using LaTeX, but I like to adjust their render to use SVG instead of image, and use a transparent background to match the overall theme of Emacs

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (plist-put! org-format-latex-options
              :scale 1.55
              :foreground "White"
              :background "Transparent")

  (setq org-preview-latex-default-process 'dvisvgm
        org-startup-with-latex-preview t)

  (pushnew! org-link-abbrev-alist
            '("sim"   . "https://sim.amazon.com/issues/%s")
            '("tt"    . "https://t.corp.amazon.com/%s")
            '("pkg"   . "https://code.amazon.com/packages/%s")
            '("ptool" . "https://phonetool.amazon.com/users/%s")
            '("crux"  . "https://code.amazon.com/reviews/%s")
            '("vs"    . "https://code.amazon.com/version-sets/%s")
            '("coe"   . "https://www.coe.a2z.com/coe/%s/content")
            '("xwiki" . "https://w.amazon.com/bin/view/%(+org-xwiki--translate-path)"))
#+end_src

 I need to adjust some of the Org fonts to use fixed pitch regardless if I'm using variable pitch. This will guarantee that tables, source blocks, and some other formatting will render properly on the UI, so let's create a function for it:

Once we create the function, we can attach it to a hook or execute it right away depending on Emacs running as a daemon or not:

And to close out my /beautification/, I want to render some unicode characters instead of some Org elements:

| Org element | Unicode character |
|-------------+-------------------|
| =- [ ]=       | ☐                 |
| =- [-]=       | ⊡                 |
| =- [X]=       | ☑                 |

And I also want to have better bullet marks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (font-lock-add-keywords 'org-mode my-org-font-lock-beautify-keywords)
#+end_src

Besides /beautification/, there are some configurations I like to have as a default behavior. The first one is how I can edit a code block on a separate buffer. By default, Org will edit it using ~switch-to-buffer-other-window~. While this seams to be a popular choice, I just can't stand the two buffers together when I can't touch on the Org file while I have the source block opened.

I will use the ='current-window= option to have the source block behaving like a normal buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq org-src-window-setup 'split-window-right)
#+end_src

After all these tweaks, we can close our parenthesis:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
) ;; after! org
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '((org-document-info
     org-document-info-keyword
     org-property-value
     org-drawer
     org-table
     org-block
     org-verbatim
     org-code
     org-date
     org-block-begin-line)
    :inherit fixed-pitch))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset 'org-document-title)

(custom-set-faces!
  '(org-document-title :inherit my-document-title :weight unspecified :extend unspecified)
  '(org-meta-line :height 0.8 :inherit font-lock-comment-face)
  '(org-special-keyword :inherit font-lock-comment-face)
  `(org-drawer :foreground ,(doom-color 'doc-comments))
  '(org-formula :inherit org-table)
  '(org-block-begin-line :height 0.8)
  '(org-block-end-line :inherit org-block-begin-line)
  '(org-tag :height 150)
  '(org-indent :inherit (org-hide fixed-pitch)))
#+end_src

Even though our configuration can renders math formulas nicely, it's still awkward to edit them once you write them. To help us with this task, I'll install a plugin called =org-fragtog=. This plugin will show the math formula with the LaTeX syntax if the cursor is inside the formula area, and will render the formula when the cursor leaves it.

First we add the plugin on our =packages.el= file:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! org-fragtog)
#+end_src

Then, we use =use-package!= to defer its loading (we will load it manually later):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! org-fragtog :defer t)
#+end_src

Another nice plugin to have is the =valign= plugin. It will align your Org tables nicely, even when you have formulas and images on them.

As with the =org-fragtog=, let's first add it to our =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! valign)
#+end_src

Then, we use =use-package!= to defer its loading as we did with =org-fragtog=, but for this plugin, we want to set the ~valign-fancy-bar~ to ~t~, to have even nicer renders of tables:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! valign
  :defer t
  :init (setq valign-fancy-bar t))
#+end_src

So far, with our configuration, we will use the entire size of the frame as our text canvas before wrapping it. This is far from ideal when you're reading a text (specially for me). I want to have narrower text to reduce the amount of focus I need to read a line.

We could configure the left and right gutter to achieve a narrower text area, or we could use another plugin for it. I tried both methods, and find out that the plugin has a better response and is easier to install and maintain.

Let's add it to our =packages.el=:

Defer its loading on our configuration, and as with the =valign= package, we will use this time to also set the maximum width for our text:

Now that I have a narrower width, the text will wrap more often, but the normal navigation keys will make the cursor jump from one line to the other, even if I have other /visual/ lines displayed.

To fix this behavior, we just need to re-bind some of the movement keys to the /visual/ version of their original command, for instance, while we have =j= bound to ~evil-next-line~, in =org-moode=, we want it bound to ~evil-next-visual-line~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
;; (map! :after org
;;       (:map org-mode-map
;;        :nvm "j" #'evil-next-visual-line
;;        :nvm "k" #'evil-previous-visual-line
;;        :nv "0" #'evil-beginning-of-visual-line
;;        :nvm "^" #'evil-first-non-blank-of-visual-line
;;        :nvm "$" #'evil-end-of-visual-line

;;        (:prefix ("g" . "goto")
;;         :desc "Next real line" :nvm "j" #'evil-next-line
;;         :desc "Previous real line" :nvm "k" #'evil-previous-line
;;         :desc "Beginning of real line" :nvm "0" #'evil-beginning-of-line
;;         :desc "First non blank of line" :nvm "^" #'evil-first-non-blank
;;         :desc "End of real line" :nvm "$" #'evil-end-of-line)))
#+end_src

While I'm sure I'm missing a command or two, these will get me started.

I also need to adjust the window navigation keys that clash with default Org bindings:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :n "s-j" #'org-next-visible-heading
      :n "s-k" #'org-previous-visible-heading
      :n "C-s-j" #'org-forward-heading-same-level
      :n "C-s-k" #'org-backward-heading-same-level
      :n "C-j" #'evil-window-down
      :n "C-k" #'evil-window-up)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :g "s-RET"     #'org-edit-special
      :g [s-return]  #'org-edit-special)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after org
      :map org-src-mode-map
      :in [s-escape] #'org-edit-src-abort
      :gin "s-RET"     #'org-edit-src-exit
      :gin [s-return]  #'org-edit-src-exit)
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-link-snippet-in-place ()
  (interactive)
  (yas-expand-snippet (yas-lookup-snippet "Link")
                      (region-beginning)
                      (region-end)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after org
      (:map org-mode-map
       :v "s-k" #'my-link-snippet-in-place))
#+end_src

At this point we can tight up everything and setup our buffer when we open an org file.

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! org-appear
  :recipe (:host github
           :repo "awth13/org-appear"))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! org-appear
  :defer t
  :init
  (setq org-appear-autolinks t
        org-appear-autosubmarkers t))
#+end_src

To separate my configuration from initialization logic, let's create another autoload function, but this time on a file used for /Org things/ (=autoload/org.el=):

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-org-buffer-config-h ()
  "Configure all aspects of an Org buffer right before we display it to the user."
  ;; Enable minor modes
  (when window-system
    (+zen/toggle)
    (valign-mode 1)
    (variable-pitch-mode 1)

    (add-hook! evil-insert-state-entry :local
      (org-fragtog-mode 1)
      (org-appear-mode 1))
    (add-hook! evil-insert-state-exit :local
      (org-fragtog-mode -1)
      (org-appear-mode -1)))
  (visual-line-mode 1)
  ;; Call org configuration functions
  (org-display-inline-images)
  ;; Ignore flycheck errors on source blocks
  (my-noflycheck-h)
  ;; Force a buffer refresh to guarantee all setup is in use
  (set-window-buffer nil (current-buffer)))
#+end_src

With this function in place, we can /hook/ it to our Org major mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'my-org-buffer-config-h)
#+end_src

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(if (getenv "GITHUB_WORKFLOW")
    (package! org-ol-tree
      :recipe (:host github
               :repo "Townk/org-ol-tree"))
  (package! org-ol-tree
    :recipe (:local-repo "~/workplace/personal/emacs/org-ol-tree")))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! org-ol-tree
  :commands org-ol-tree
  :init
  (map! :map org-mode-map
        :localleader :prefix ("g" . "goto")
        :desc "Open outline"  "o" #'org-ol-tree)

  (setq org-ol-tree-ui-window-header-format
        '((:eval (concat " ☰ " (propertize "Outline" 'face '(:inherit 'my-default-ui :height 0.8)))))))
#+end_src

** TODO Prose writing
I don't like to write. After reading this page or any other text I published you might think this is a lie, but it's not. I say way more then I need at any given moment. Suffice to say that this takes a big chunk of my energy, and on top of that, I'm not really good at it. This means that for my crazy brain, there is not much reward when I write, and in some times, there is actually anxiety and discomfort.

With that out of the way, I need to acknowledge that, currently in my career, there is no way I can get away with /not writing/. There are too much design, architecture, plans, and projects involved on my day to day work, that my team and I need some form of record of our decisions. And if writing is inevitable, I should, at least, try to make it less painful.

For me, this means I should have a tool that offers me the power required to do any kind of writing, but in the same time, makes my life easier when doing the /writing thing/.

Emacs and Org Mode fulfill the /power/ part of my goal, and this configuration will try to tackle the second.

Let's look into my list of requirements for writing:

- File templates :: My setup should have a set of file templates that would help me start writing something faster. At any time while using Emacs, I can start a new document and select one of these templates, and Emacs will create the file on the right location, using the selected template;
- No hard line wrap :: While I can't stand soft-wraps on code, I'm getting used to it when I'm writing text, specially now that I can navigate using /visual lines/ on Org Mode. So, this requirement is to make sure I use soft wraps while editing an Org file;
- Inline images :: If I add an image to a text, I want the image to show up right away. Also, if I open a file containing an image, Emacs should display the image automatically. I also want to auto-split the image into chunks so when navigate the text with the cursor, the screen does not jump over the image.
- Inline formulas :: As with images, I want to render math formulas automatically;
- Formatted tables :: Tables on my Org files should stay aligned all the time, and render with proper borders;
- Focus writing :: When I need to dive deep into creating a document, it's useful to remove distractions from my writing environment. Besides getting rid of UI elements, I would like to have the same /Focus Mode/ behavior from [[https://ia.net/writer][iA Writer]];
- Snippets :: I like to have a snippet system to help me with boilerplate writing for Org;

Although we already covered most of this list of the previous section, we still need to configure /File templates,/ some personal /Snippets/, and /Focus Writing/, so let's get to it.

*** Dictionary and writing helpers

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! lexic
  :recipe (:host github
           :repo "tecosaur/lexic"))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :init
  (set-popup-rule! "^\\*lexic\\*$"
    :slot 2   :vslot -1     :side 'right  :width 100 :height 0.4
    :select t :modeline nil :autosave nil :ttl 0     :quit t)

  :config
  (cl-delete-if (lambda (spec)
                  (equal (car-safe spec) "Online Etymology Dictionary"))
                lexic-dictionary-specs)

  (pushnew! lexic-dictionary-specs
            '("GNU Collaborative International Dictionary of English"
              :short "Meaning"
              :formatter lexic-format-webster
              :priority 1)
            '("English - Portuguese"
              :short "Portuguese"
              :formatter lexic-format-online-etym
              :priority 2)
            '("Online Etymology Dictionary"
              :short "Origin"
              :formatter lexic-format-online-etym
              :priority 4))

  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-lexic-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'lexic-mode-hook #'my-lexic-buffer-config-h)
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defadvice! my-dictionary-definition-lexic-a (identifier &optional _)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src

#+caption: Commands to install custom aspell dictionary
#+begin_src shell :tangle no
cd $TMPDIR
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=95&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"
cd aspell6-en-custom
./configure && make && sudo make install
cd ..
rm -rf aspell6-en-custom*
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-aspell-local-data-dir (expand-file-name "~/.local/share/aspell")
  "Directory of Aspell dictionaries.")

(unless (file-exists-p my-aspell-local-data-dir)
  (mkdir my-aspell-local-data-dir t))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-aspell--personal-dictionary (expand-file-name "personal.en.pws" my-aspell-local-data-dir)
  "File path for my personal word dictionaries.")

(when (not (file-exists-p my-aspell--personal-dictionary))
  (append-to-file "personal_ws-1.1 en 0 utf-8" nil my-aspell--personal-dictionary))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-aspell-cmd-flags (&optional camel-case &rest extra-args)
  "Return the list of arguments Emacs should use to run aspell.

You can use this list of arguments directly as the value of `ispell-extra-args'.
If CAMEL-CASE is a non-nil value, the list of arguments will include the
\"--camel-case\" option.

If EXTRA-ARGS is not nil, this function will append its value to the result."
  (append '("--sug-mode=ultra") extra-args (when camel-case '("--camel-case"))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! ispell
  (setq ispell-personal-dictionary my-aspell--personal-dictionary)
  (setq ispell-really-aspell t)
  (setq ispell-extra-args (my-aspell-cmd-flags t))

  ;; (add-hook! org-mode
  ;;   (defun my-spell-add-extra-ignores-to-org-h ()
  ;;     "Configure `ispell-skip-region-alist' for `org-mode'."
  ;;     (make-local-variable 'ispell-skip-region-alist)
  ;;     (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  ;;     (add-to-list 'ispell-skip-region-alist '("~" "~"))
  ;;     (add-to-list 'ispell-skip-region-alist '("=" "="))
  ;;     (add-to-list 'ispell-skip-region-alist '("\\[\\[" . "]\\["))
  ;;     (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
  ;;     (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "#\\+end_src"))

  ;;     (setq-local ispell-extra-args (my-aspell-cmd-flags nil
  ;;                                                            "--lset-filter=url:email:context"
  ;;                                                            "--context-visible-first=true"
  ;;                                                            "--add-context-delimiters=~ ~"
  ;;                                                            "--add-context-delimiters== ="
  ;;                                                            "--add-context-delimiters=[[ ]["))))
  )
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-spell-fu-find-urls (point-start point-end)
  (let ((url-ranges (list)))
    (save-match-data
      (save-excursion
        (goto-char point-start)
        (while (re-search-forward browse-url-button-regexp point-end t)
          (push (cons (match-beginning 0) (match-end 0)) url-ranges))
        url-ranges))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-spell-fu-check-range (point-start point-end)
  "Check spelling for POINT-START & POINT-END ignoring urls."
  (spell-fu--remove-overlays point-start point-end)
  (with-syntax-table spell-fu-syntax-table
    (save-match-data
      (save-excursion
        (goto-char point-start)
        (while (re-search-forward spell-fu-word-regexp point-end t)
          (let ((url-ranges (my-spell-fu-find-urls point-start point-end))
                (word-start (match-beginning 0))
                (word-end (match-end 0)))
            (unless (seq-some (lambda (range)
                                (or (and (> word-start (car range))
                                         (< word-start (cdr range)))
                                    (and (> word-end (car range))
                                         (< word-end (cdr range)))))
                              url-ranges)
              (when (spell-fu--check-faces-at-point
                     word-start
                     spell-fu-faces-include
                     spell-fu-faces-exclude)
                (spell-fu-check-word word-start word-end (match-string-no-properties 0))))))))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! spell-fu
  (setq spell-fu-check-range 'my-spell-fu-check-range))
#+end_src

Rules:
- https://github.com/textlint-rule/textlint-rule-no-start-duplicated-conjunction
 
#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! flycheck
  (setq flycheck-textlint-config "~/.config/textlint/config.json"))
#+end_src

- https://emacs.stackexchange.com/questions/48587/have-flycheck-skip-certain-regions
- https://emacs.stackexchange.com/questions/47878/how-can-i-disable-a-specific-lint-error-for-emacs-lisp-using-flycheck

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defvar my-noflycheck-region-alist
  '((org-mode ("^[ \\t]*?#\\+begin_\\(?:src\\|quote\\)" . "^[ \\t]*?#\\+end_\\(?:src\\|quote\\)")))
  "An association list between major modes and a noflycheck region delimiters.

The region delimiters are two regular expressions that should match the
beginning and the end of the region respectively.")
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-noflycheck-should-skip-error-h (err)
  "Ignore flycheck ERR if it happens inside a 'no flycheck' region."
  (when-let ((region (car (alist-get major-mode my-noflycheck-region-alist)))
             (_ (save-excursion
                  (save-match-data
                    (let* ((start (car region))
                           (end (cdr region))
                           (both (format "\\(?:\\(%s\\)\\|%s\\)" start end)))
                      (goto-char (flycheck-error-pos err))
                      (and (re-search-backward both nil t)
                           (match-beginning 1)))))))
    (setq-local flycheck-current-errors (remove err flycheck-current-errors))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-noflycheck-should-skip-urls-h (err)
  "Ignore flycheck ERR if it happens inside a 'no flycheck' region."
  (when-let ((_ (save-excursion
                  (save-match-data
                    (when-let ((err-pos (flycheck-error-pos err)))
                      (goto-char err-pos)
                      (thing-at-point 'url))))))
    (setq-local flycheck-current-errors (remove err flycheck-current-errors))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-noflycheck-h ()
  "Add a skip flycheck for regions defined at `my-noflycheck-region-alist'."
  (require 'flycheck)
  (add-hook 'flycheck-process-error-functions #'my-noflycheck-should-skip-error-h nil t)
  (add-hook 'flycheck-process-error-functions #'my-noflycheck-should-skip-urls-h nil t))
#+end_src

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! flycheck-posframe)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(flycheck-posframe-border-face :foreground "#000000")
  '(flycheck-posframe-face :inherit my-default-ui))

(use-package! flycheck-posframe
  :hook ((flycheck-mode . flycheck-posframe-mode))
  :init
  (setq flycheck-posframe-border-width 1
        flycheck-posframe-prefix
        (format "%s\t" (all-the-icons-material "close" :height 0.7 :v-adjust -0.1))
        flycheck-posframe-info-prefix
        (format "%s\t" (all-the-icons-material "info" :height 0.7 :v-adjust -0.1))
        flycheck-posframe-warning-prefix
        (format "%s\t" (all-the-icons-material "warning" :height 0.7 :v-adjust -0.1))
        flycheck-posframe-error-prefix
        (format "%s\t" (all-the-icons-material "error" :height 0.7 :v-adjust -0.1)))
)
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defadvice! my-flycheck-posframe-format-errors-a (fun &rest args)
  "Advice to add a top and bottom padding to the error message."
  :around 'flycheck-posframe-format-errors
  (concat (propertize "  \n" 'face '(:height 60))
          (apply fun args)
          (propertize "\n  " 'face '(:height 60))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defadvice! my-flycheck-posframe-show-posframe-a (errors)
  "Display ERRORS, using posframe.el library."
  :override 'flycheck-posframe-show-posframe
  (posframe-hide flycheck-posframe-buffer)
  (when (and errors
             (not (run-hook-with-args-until-success 'flycheck-posframe-inhibit-functions)))
    (let ((poshandler (intern (format "posframe-poshandler-%s" flycheck-posframe-position))))
      (unless (functionp poshandler)
        (setq poshandler nil))
      (flycheck-posframe-check-position)
      (posframe-show
       flycheck-posframe-buffer
       :string (flycheck-posframe-format-errors errors)
       :background-color (face-background 'flycheck-posframe-background-face nil t)
       :position (point)
       :internal-border-width flycheck-posframe-border-width
       :internal-border-color (face-foreground 'flycheck-posframe-border-face nil t)
       :poshandler poshandler
       :hidehandler #'flycheck-posframe-hidehandler
       :left-fringe 10
       :right-fringe 10))))
#+end_src

*** Templates

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-file-templates-yasnippet-dir (expand-file-name "share/templates" doom-private-dir))
(pushnew! yas-snippet-dirs 'my-file-templates-yasnippet-dir)
#+end_src


#+caption: $DOOMDIR/share/templates/org-mode/__
#+begin_src snippet :tangle share/templates/org-mode/__
# name: Blank Org File
# key: __
# --
#+TITLE: ${1:`(s-titleized-words (file-name-sans-extension (buffer-name)))`}
#+AUTHOR: `user-full-name`
#+EMAIL: `user-mail-address`
#+DATE: `(format (format-time-string "%B %%s, %Y") (string-to-number (format-time-string "%d")))`
#+LANGUAGE: ${2:en}

`%`$0
#+end_src


**** TODO Define a Hydra for /new documents/ to use my templates

*** Focus Writing

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! focus)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! focus :defer t)

(map! :leader :prefix ("t" . "toggle")
      :desc "Focus mode" :mvn "o" #'focus-mode
      :desc "Focus mode (RO)" :mvn "O" #'focus-read-only-mode)
#+end_src

*** Snippets
Even though writing does not have boilerplate typing /per-se/, Org mode still has a formal syntax to follow. Most of the syntax are straightforward, but some could use a snippet help to make it easier and faster to type them.

This section shows the snippets I decide to use for writing.

Before defining the snippets though, I need to adjust the ~yas-keymap~ to behave properly with evil:


**** Source blocks
This journey of literate configuration made me realize how much faster is to /prepare/ source blocks using snippets.

The first snippet, is a simple =emacs-lisp= snippet that I use all the time:

#+caption: $DOOMDIR/snippets/org-mode/src-emacs-lisp
#+begin_src snippet :tangle snippets/org-mode/src-emacs-lisp
# name: #+begin_src emacs-lisp
# uuid: emacs-lisp
# key: <el
# --
`(when buffer-file-name (format "#+caption: $DOOMDIR/%s.el\n" (file-name-base buffer-file-name)))`#+begin_src emacs-lisp
`%`$0
,#+end_src
#+end_src

Then I have the same snippet, but allowing me to add a ~:tangle~ header to it:

#+caption: $DOOMDIR/snippets/org-mode/src-emacs-lisp-tangled
#+begin_src snippet :tangle snippets/org-mode/src-emacs-lisp-tangled
# name: #+begin_src emacs-lisp :tangle
# uuid: emacs-lisp-tangle
# key: <elt
# --
${1:$(unless (or (string-blank-p yas-text) (equal yas-text "no"))
        (format "#+caption: %s\n" yas-text))
}#+begin_src emacs-lisp `":tangle"` ${1:$$(unless (or yas-moving-away-p yas-modified-p)
                            (yas-auto-next
                              (condition-case nil
                                  (let ((fname (read-file-name "Tangle to file: ")))
                                    (if fname
                                        (file-relative-name fname (file-name-directory (or buffer-file-name ".")))
                                      "no"))
                                ('quit "no"))))}
`%`$0
,#+end_src
#+end_src

And for a more generic approach, I have this snippet where you can define the language, if you want a tangle header, and if you do, allows you to select the file:

#+caption: $DOOMDIR/snippets/org-mode/src-tangled
#+begin_src snippet :tangle snippets/org-mode/src-tangled
# name: #+begin_src on steroids
# uuid: src_block
# key: <st
# --
${3:$(unless (or (string-blank-p yas-text) (equal yas-text "no"))
        (format "#+caption: %s\n" yas-text))
}#+begin_src ${1:emacs-lisp} ${2:`":tangle"` ${3:$$(unless (or yas-moving-away-p
                                                               yas-modified-p)
                            (yas-auto-next
                              (condition-case nil
                                  (let ((fname (read-file-name "Tangle to file: ")))
                                    (if fname
                                        (file-relative-name fname (file-name-directory (or (buffer-file-name) ".")))
                                      "no"))
                                ('quit "no"))))}}
`%`$0
,#+end_src
#+end_src

The last snippets I consider useful for source blocks are captions. On the two snippets with tangled files, the capture mark is already there, but if I want to add a caption to the non-tangled snippet I have to do it by hand. So, let's create a snippet to help us with this:

#+caption: $DOOMDIR/snippets/org-mode/caption
#+begin_src snippet :tangle snippets/org-mode/caption
# name: #+caption:
# key: cap
# --
#+caption: $0
#+end_src

This snippet is fine, but we still have to type the filename there. Let's create another one to make this task even easier:

#+caption: $DOOMDIR/snippets/org-mode/caption-file
#+begin_src snippet :tangle snippets/org-mode/caption-file
# name: #+caption: filename
# uuid: caption-file
# key: capf
# --
#+caption: ${1:$$(unless (or yas-moving-away-p yas-modified-p)
                            (yas-auto-next
                              (file-relative-name
                                (read-file-name "Tangle to file: ")
                                (file-name-directory (or (buffer-file-name) "."))
                              )))}$0
#+end_src

**** Org elements
#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-links-in-kill-ring ()
  "Return a list of links in kill ring."
  (require 'goto-addr)
  (let* ((kill-ring-kills (mapcar #'substring-no-properties kill-ring))
         (clipboard (gui-get-selection 'CLIPBOARD 'NSStringPboardType))
         (clipboard-url (when (string-match goto-address-url-regexp clipboard)
                          (list (match-string 0 clipboard))))
         (potential-links))
    (dolist (kill kill-ring-kills)
      (let (last-match)
        (while
            (prog1
                (string-match goto-address-url-regexp
                              kill last-match)
              (setq last-match (match-end 0)))
          (cl-pushnew (match-string 0 kill) potential-links)
          )))
    (append clipboard-url (delete-dups potential-links))))
#+end_src

#+caption: $DOOMDIR/snippets/org-mode/link
#+begin_src snippet :tangle snippets/org-mode/link
# name: Link
# key: link
# --
[[${1:$$(unless (or yas-moving-away-p yas-modified-p)
  (let ((links (my-links-in-kill-ring)))
    (if links
        (yas-auto-next
          (completing-read "Choose the URL to link: " links))
      "url")))}][${2:`(or yas-selected-text "description")`}]]$0
#+end_src

** TODO Reading or reviewing
- Narrower width
- Visual motion
- Show document structure on sidebar
- Annotations
  + Referenceable
  + Annotate external documents (default to Doom)

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! nov)
#+end_src

** TODO Publishing
- Blog or site post
- Email document
- Wiki entry

#+caption: $DOOMDIR/snippets/org-mode/macro
#+begin_src snippet :tangle snippets/org-mode/macro
# name: #+BEGIN_MACRO ... block
# uuid: macro
# key: <m
# --
#+attr_block: :macro ${1:info} $2
#+BEGIN_MACRO
`%`$0
#+END_MACRO
#+end_src

** TODO Presenting
- Use =reveal.js= inside a WebKit XWidget in full screen

** TODO Note Taking
Here in this section I need to come clean to the reader. I'm a horrible note taker! I have [[https://www.cdc.gov/ncbddd/adhd/facts.html][ADHD]] and my capacity to keep up with any system to take notes is as short as a [[https://www.cdc.gov/ncbddd/adhd/facts.html][fruit fly's attention span]]. That said, one of the longest streaks of success keeping up with notes I had in the past, was when I tried Org mode for the first time. I believe if I have a setup that makes taking notes effortless, I might be able to finally start taking notes and refer to them when needed.

After a lot of reading, consultation, and thinking, I believe I found a system I will enjoy working with. Let me describe it to you.

One of the constants I found when searching for a note taking system was the fact that writing down a note (regardless of its type), has to happen in less than two seconds or I don't get motivated to do it all the time. This time is valid to take notes from a computer, as well as on the go. For some individuals, having a small notebook at hand all the time, is crucial for them. Since I'm more of a tech guy, my system will use exclusively computer software.

To get under these two seconds to take a note when I'm on a computer, I defined a single entry point for all notes. This way I can optimize this process inside and outside Emacs if I want.

My entry point for notes is [[https://github.com/bastibe/org-journal][Org Journal]]. I will use an entry scheme of one file per year, and create an [[https://orgmode.org/manual/Capture.html][org-capture]] system that will use this single journal file and help me achieve the two seconds mark.

Part of my strategy is to have one capture template per type of note to reduce the necessary amount of thinking not related to the note itself. Another artifact I will use is [[https://joaotavora.github.io/yasnippet/][Yasnippet]] instead of =org-capture= templates. The reason for this decision is to keep a visual track on the entry text. With the standard =org-capture=, I have to move my eyes from top to bottom of the screen to look between the template text and the input field.

I will take notes any time I feel the need, but here are the main topics for my notes:

- Fleet notes :: These are the /quick notes/ of the day. I will use fleet notes any time a note does not fit on anyone of the next categories;
- Journal entries :: When need to add an event on my personal journal, I will use this category. I need to clarify though, that a /personal journal/ for me, is anything that happens to myself, regardless if is a work related event or not;
- Meeting notes :: Should happen on any meeting, I must review them no longer than 30 minutes after it,  and must include:
  + List of participants;
  + Meeting time;
  + Meeting subjects;
  + Important points on the meeting;
  + Action items and their owners;
- Support :: When I spend some time with a co-worker helping her on any subject, I will have a note about this support containing:
  + Co-worker's name;
  + Support's subject;
  + Start and end time;
  + Action items for me or the co-worker;
- Idea :: Whenever something interesting pops from my brain, I will try to capture it in this category;
- Link :: When I find something interesting online, or something I should spend some time reading or studying;
- Past entry :: If I remember of something that happens a couple days earlier, or when I want to make a journal entry on the past, I will use this category;

On the end of each day, I will sit down in front of my computer to review the notes I took on the day. I will think about each note I took and verify if its worth ot keeping it. If it is, I'll try to synthesize the note on my own words and relate it with previous notes.

I will be able to search notes using their reference label, title, tags, or content (a great package for this is [[https://github.com/jrblevin/deft][Deft]]).

*** Capturing

Talk about capture in general:
- How am I going to use it?
- How am I going to implement it with Yasnippets?
- Any goals for this area?

#+begin_src text :tangle no
[n]     ● Fleet note
[j]...  ● Journal
[t]...  ● Tasks
[c]     ● Contact
[p]...  ● Project
--------------------------------------------------------------------------------
[q]     ● Abort
#+end_src

Start with the open definition for =org-capture=:

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defconst my-capture--note-frame-height 15
  "Number of lines a note frame should have when capturing a long note.")

(defconst my-capture--long-note-frame-height 35
  "Number of lines a note frame should have when capturing a long note.")

(defconst my-capture--menu-width 50
  "Number of lines a note frame should have when capturing a long note.")

(defconst my-capture--yas-prefix "--DOOM-ORG-CAPTURE-YAS-PREFIX--:"
  "String used to identify a yasnippet template on a capture buffer")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-capture-yasnippet-dir (expand-file-name "share/capture" doom-private-dir)
  "Directory containning all capture snippets.")
(pushnew! yas-snippet-dirs 'my-capture-yasnippet-dir)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! org-capture
  :after all-the-icons
  :commands (org-capture +org-capture/open-frame)
  :init
  (add-hook 'org-capture-mode-hook #'my-capture--yas-expand-h)
  (add-hook 'org-capture-after-finalize-hook #'my-capture--finish-h)
  (add-hook 'window-state-change-hook #'my-bring-org-capture-to-front-h)
  :config
  (setq +org-capture-changelog-file "CHANGELOG.org")
  (setq org-capture-templates-contexts '(("p" (my-capture-projects-p))))
  (setq +org-capture-fn (lambda ()
                          (interactive)
                          (set-window-parameter nil 'mode-line-format 'none)
                          (set-window-parameter nil 'header-line-format 'none)
                          (setq default-minibuffer-frame (org-capture))))

  (map! (:map org-capture-mode-map
         :in [s-return] #'org-capture-finalize
         :in [s-escape] #'org-capture-kill)
        (:leader
         :desc "Org Capture"           "X" #'+org-capture
         (:prefix ("n" . "notes")
          :desc "Org capture"          "n" #'+org-capture/open-frame))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (setq org-capture-templates '()))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-bring-org-capture-to-front-h ()
  (when-let ((captur-buffer (seq-find (lambda (buf) (string-prefix-p "CAPTURE" (buffer-name buf)))
                                      (buffer-list))))
    (my-bring-buffer-to-front captur-buffer)
    (when (eq (org-roam-buffer--visibility) 'visible)
      (org-roam-buffer-deactivate))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--adjust-frame (&optional extended-p frame)
  "Dinamically adjust the capture FRAME width to WIDTH and reposition it on the
center of the screen."
  (when (+org-capture-frame-p)
    (set-frame-size (or frame (selected-frame))
                    (+ fill-column 20)
                    (if extended-p
                        my-capture--long-note-frame-height
                      my-capture--note-frame-height))
    (my-capture--reposition-frame frame)))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--reposition-frame (&optional frame)
  "Position FRAME around the center of the screen."
  (let ((frame-w (window-pixel-width))
        (frame-h (window-pixel-height)))
    (set-frame-position (or frame (selected-frame))
                        (/ (- (display-pixel-width) frame-w) 2)     ;; X
                        (/ (- (display-pixel-height) frame-h) 3)))) ;; Y
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture--yas-expand-h ()
  "Expand `my-capture--yas-prefix' on the template."
  (setq +org-capture--auto-align-tags-store org-auto-align-tags)
  (let ((saved-point (point)))
    (goto-char (point-min))
    (if (search-forward-regexp (concat my-capture--yas-prefix "\\([^:]*\\):") nil t)
        (progn
          (setq org-auto-align-tags nil)
          (goto-char (match-end 0))
          (replace-match (match-string 1))
          (yas-expand))
      (goto-char saved-point)))

  ;; (org-num-mode -1)
  (tab-line-mode -1)
  (ws-butler-mode -1)
  (setq-local org-startup-folded nil))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-yasnippet (snippet)
  "Returns a snippet mark with the given SNIPPET used to expand it with yasnippet
when the capture finishes.

SNIPPET can be a string or a symbol.

The snippet mark will have the format:

\"--DOOM-ORG-CAPTURE-YAS-PREFIX--:<snippet name>:\""
  (concat my-capture--yas-prefix
          (if (stringp snippet)
              snippet
            (symbol-name snippet))
          ":"))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture--finish-h ()
  "Clean up any outstanding variable and values set when capture
starts."
  (setq org-auto-align-tags +org-capture--auto-align-tags-store)
  (setq +org-capture--auto-align-tags-store nil))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-template-selection ()
  "Returns the text selected on the buffer that originated the capture. If the
selection is the entire buffer, return an org link to buffer."
  (with-current-buffer (org-capture-get :original-buffer)
    (when (region-active-p)
      (or (my-capture--mu4e-headers-selected)
          (my-capture--mu4e-view-selected)
          (my-capture--buffer-selected)
          ""))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--mu4e-headers-selected (&optional buf-name)
  "When on a mu4e-headers buffer, store an org link to each one of the selected
messages and return them all as a string."
  (when (and (boundp 'mu4e~headers-buffer-name)
             (string= (or buf-name (buffer-name)) mu4e~headers-buffer-name))
    (let* ((beg (region-beginning))
           (end (region-end))
           (lines (count-lines beg end)))
      (save-excursion
        (goto-char beg)
        (while (< (point) end)
          (org-store-link t t)
          (forward-line 1)))
      (with-temp-buffer
        (org-insert-all-links lines)
        (buffer-string)))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--mu4e-view-selected (&optional buf-name)
  "When on a mu4e-view buffer, store an org link to the message and return it as a
string with the selected text as a block-quote. If the selection is the entire
buffer, just return the org link."
  (when (and (boundp 'mu4e~view-buffer-name)
             (string= (or buf-name (buffer-name)) mu4e~view-buffer-name))
    (let* ((beg (region-beginning))
           (end (region-end))
           (full-buf-sel-p (and (= beg (point-min))
                                (= end (point-max))))
           (buf-quote (when (not full-buf-sel-p) (buffer-substring beg end))))
      (org-store-link t t)
      (with-temp-buffer
        (insert "- ")
        (org-insert-last-stored-link 1)
        (when buf-quote
          (insert "#+BEGIN_QUOTE\n")
          (insert buf-quote)
          (insert "#+END_QUOTE\n"))
        (buffer-string)))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--buffer-selected ()
  "When there is an active selection in the current buffer,
returns an org link to the current buffer with the selection as a blockquote. If
the selection is the entire buffer, just return the org link."
  (let ((sel-text (let* ((beg (region-beginning))
                         (end (region-end))
                         (full-buf-sel-p (and (= beg (point-min))
                                              (= end (point-max))))
                         (buf-file (expand-file-name (buffer-file-name)))
                         (buf-name (buffer-name))
                         (buf-linum (line-number-at-pos beg t))
                         (buf-quote (when (not full-buf-sel-p) (buffer-substring beg end)))
                         (quote-what (if (and buf-quote (derived-mode-p 'prog-mode))
                                         (format "SOURCE %s"
                                                 (s-chop-suffix "-mode" (symbol-name major-mode)))
                                       "QUOTE")))
                    (with-temp-buffer
                      (when (file-exists-p buf-file)
                        (insert (format "- [[file:%s::%d][%s]]\n" buf-file buf-linum buf-name)))
                      (when buf-quote
                        (insert (format "#+BEGIN_%s\n" quote-what))
                        (insert buf-quote)
                        (insert (format "#+END_%s\n" quote-what)))
                      (buffer-string)))))
    (unless (s-blank-str-p sel-text) sel-text)))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-projects-p ()
  "Retuns true when current buffer belongs to current open project."
  (with-current-buffer (or (org-capture-get :original-buffer) (current-buffer))
    (let* ((proj-root (doom-project-root))
           (proj-root (when proj-root (expand-file-name proj-root)))
           (buf-path (buffer-file-name))
           (buf-path (when buf-path (expand-file-name buf-path))))
      (and proj-root
           buf-path
           (string-prefix-p proj-root buf-path)))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-description (&rest args)
  "Returns a formatted capture description.

ARGS is a declarative builder for the new description:

`:text' (required) - The string displayed on the capture item.
`:icon' (optional) - A cons cell with the icon symbol (check
    `+org-capture-supported-icons' for supported symbols).

Example:

  (my-capture-description :text \"Add journal entry\"
                            :icon '(journal . \"#ff00ff\"))"
  (let ((text (plist-get args :text))
        (icon (plist-get args :icon)))
    (when (or (null text)
                (string-blank-p text))
      (error "A capture description requires a text."))
    (if icon
        (progn
          ;; (unless (and (consp icon)
          ;;              (my-supported-icons-p (car-safe icon))
          ;;              (stringp (cdr-safe icon)))
          ;;   (error (concat "A capture description icon must be a cons cell with"
          ;;                  " one of my-supported-icons symbol and a string color.")))
          (format "%s %s" (my-icon (car icon) (cdr icon)) text))
      text)))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-heading-template (&rest args)
  "Returns a formatted capture template for a heading.

ARGS should all be string that will get concatenated with no spaces between
them. Default to \"%?\"."
  (let* ((content (when args (s-join "" args)))
         (content (if (s-matches-p content "%|\\([^|]*\\)|")
                      (s-trim (s-replace-all '((" %? " . " ") ("%?" . "")) content))
                    (or content "%?"))))
    (concat (when (not (s-starts-with-p "*" content))
              "%(my-capture-heading-prefix) ")
            (replace-regexp-in-string "%|\\([^|]*\\)|"
                                      "%(my-capture-yasnippet 'capture-\\1)%?"
                                      content)
            "\n%(my-capture-template-selection)")))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-heading-prefix ()
  "Returns a string of `*` characters representing an org header level. The number
of characters is the one on the org-capture `:heading-level' property or
calculated by the org-capture `:olp' property size."
  (let ((level (org-capture-get :heading-level))
        (olp-size (1+ (length (org-capture-get :olp)))))
    (s-repeat (max 1 (or level olp-size)) "*")))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-position-cursor ()
  "Asks user for a timestamp and store it for template use. It also position the
cursor on the correct place for a new entry, and adjust the capture frame width
to `fill-column' before start editing."
  (my-capture--adjust-frame (org-capture-get :clock-in))
  (let* ((read-time (org-capture-get :read-time))
         (read-time-labal (or (org-capture-get :read-time-label) "Timestamp"))
         (olp (org-capture-get :olp))
         (header-point (org-roam-capture-find-or-create-olp olp))
         existent-olp)
    (when read-time
      (org-capture-put :time-read (org-read-date t t nil read-time-labal)))
    (if (not olp)
        (goto-char (point-max))
      (goto-char header-point)
      (org-end-of-subtree)
      (move-end-of-line nil))
    (newline)))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-file()
  (let* ((file-name-format (org-capture-get :file-name-format))
         (file-name (s-trim (org-capture-fill-template file-name-format)))
         (file-path (expand-file-name file-name (when (not (s-starts-with-p "/" file-name)) org-directory)))
         (file-header (org-capture-get :file-header)))
    (if (file-exists-p file-path)
        (find-file file-path)
      (make-directory (file-name-directory file-path) t)
      (find-file file-path)
      (when file-header
        (insert (org-capture-fill-template file-header)))
      (set-buffer-modified-p nil))
    (my-capture-position-cursor)
    (when (eq 'visible (org-roam-buffer--visibility))
      (org-roam-buffer-deactivate))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-time-read ()
  "Returns the last timestamp captured, formatted with the format specified on
`org-time-stamp-formats'. If user didn't capture any date, returns current
time."
  (format-time-string (cdr-safe org-time-stamp-formats) (org-capture-get :time-read)))
#+end_src

**** Dailies
#+begin_src text :tangle no
[s]     ● Support
[m]     ● Meeting
[c]     ● Code review
[i]     ● Idea
[l]     ● Interesting link
--------------------------------------------------------------------------------
[q]     ● Abort
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst my-roam-dailies-file-name "notes/daily/daily-notes-%<%Y-%m-%d>.org"
  "Filename format for the Daily Notes file.")

(defconst my-roam-dailies-header (concat "#+TITLE: Daily notes for %<%A, %B %-e, %Y>\n"
                                           "#+STARTUP: overview\n"
                                           "#+CATEGORY: dailies\n"
                                           "\n")
  "Template used to create new Daily Notes files.")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("d"  ,(my-capture-description :text "Daily notes" :icon `(notes . ,(doom-color 'green)))))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("dd"  ,(my-capture-description :text "Fleet note" :icon `(notes . ,(doom-color 'blue 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %?")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :kill-buffer t
               :empty-lines-after 2
               :olp ("Fleet notes")))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("ds" ,(my-capture-description :text "Support" :icon `(help . ,(doom-color 'orange 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|support|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :clock-in t
               :kill-buffer t
               :empty-lines-after 2
               :olp ("Meeting notes")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-mode/capture-support
#+begin_src snippet :tangle share/capture/org-mode/capture-support
# name: Notes for new support request
# key: capture-support
# --
Support about ${1:Support topic}  `":support:"`
- Requested by ${2:Coworker Name}
- $0
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("dm" ,(my-capture-description :text "Meeting" :icon `(meeting . ,(doom-color 'cyan 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|meeting|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :clock-in t
               :kill-buffer t
               :empty-lines-after 2
               :olp ("Meeting notes")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-mode/capture-meeting
#+begin_src snippet :tangle share/capture/org-mode/capture-meeting
# name: Notes from meetings
# key: capture-meeting
# --
${1:Meeting topic}  `":meeting:"`

,*** Attendees
-`" "`

,*** Notes
- $0
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("dc" ,(my-capture-description :text "Code review" :icon `(review . ,(doom-color 'green 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|cr|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :clock-in t
               :kill-buffer t
               :empty-lines-after 2
               :olp ("Meeting notes")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-mode/capture-cr
#+begin_src snippet :tangle share/capture/org-mode/capture-cr
# name: New code review started
# key: capture-cr
# --
Started code review for ${1:Coworker Name}  `":cr:"`
- Review link: [[${2:url}][${2:$$(file-name-base yas-text)}]]
- $0
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("dv" ,(my-capture-description :text "Interview" :icon `(review . ,(doom-color 'green 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|interview|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :clock-in t
               :kill-buffer t
               :empty-lines-after 2
               :olp ("Meeting notes")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-mode/capture-interview
#+begin_src snippet :tangle share/capture/org-mode/capture-interview
# name: Notes for interview
# key: capture-interview
# --
Interview with ${1:Candidate Name}  `":interview:"`
:PROPERTIES:
:INTERVIEW_ID: ${1:$(file-name-base (car (s-split "?" (url-filename (url-generic-parse-url yas-text)))))}
:URL: [[${1:$$(unless (or yas-moving-away-p yas-modified-p)
  (let ((links (my-links-in-kill-ring)))
    (if links
        (yas-auto-next
          (completing-read "Choose the URL to link: " links))
      "url")))}][Interview page]]
:FEEDBACK_URL: [[https://hire.amazon.com/interviews/${1:$(file-name-base (car (s-split "?" (url-filename (url-generic-parse-url yas-text)))))}/feedback_vote][Feedback page]]
:END:

,*** Notes
- $0

,*** Evaluation
- Data points evaluated:
  | ☐ Customer Obsession              | ☐ Ownership            | ☐ Invent and Simplify       |
  | ☐ Are Right, A Lot                | ☐ Learn and Be Curious | ☐ Hire and Develop the Best |
  | ☐ Insist on the Highest Standards | ☐ Think Big            | ☐ Bias for Action           |
  | ☐ Frugality                       | ☐ Earn Trust           | ☐ Dive Deep                 |
  | ☐ Have Backbone                   | ☐ Disagree and Commit  | ☐ Deliver Results           |
- Inclined:
  + [ ] Yes
    + [ ] Strongly inclined
  + [ ] No
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("di" ,(my-capture-description :text "Idea" :icon `(idea . ,(doom-color 'yellow 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|idea|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :kill-buffer t
               :empty-lines-after 1
               :olp ("Ideas")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-journal-mode/capture-idea
#+begin_src snippet :tangle share/capture/org-mode/capture-idea
# name: New Idea
# key: capture-idea
# --
${1:Idea!}  :idea:
$0
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("dl" ,(my-capture-description :text "Interesting link" :icon `(globe . ,(doom-color 'blue 256)))
               plain (function my-capture-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %|link|")
               :file-name-format ,my-roam-dailies-file-name
               :file-header ,my-roam-dailies-header
               :kill-buffer t
               :empty-lines-after 1
               :olp ("Links")))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-journal-mode/capture-link
#+begin_src snippet :tangle share/capture/org-mode/capture-link
# name: Interesting link
# key: capture-link
# --
Check out ${1:Title}
- Link: ${2:url}
${3:- ${4:note}}
$0
#+end_src

**** Journal entries

#+begin_src text :tangle no
[s]     ● New entry
[p]     ● Past entry
--------------------------------------------------------------------------------
[q]     ● Abort
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("j"  ,(my-capture-description :text "Journal" :icon `(journal . ,(doom-color 'blue 256))))
              ("jj"  ,(my-capture-description :text "New entry" :icon `(journal . ,(doom-color 'green)))
               plain (function my-capture-journal-file)
               ,(my-capture-heading-template "%<%H:%M%#p> - %?")
               :empty-lines-after 1
               :kill-buffer t)
              ("jp" ,(my-capture-description :text "Past entry" :icon `(history . ,(doom-color 'violet 256)))
               plain (function my-capture-journal-file-for-timestamp)
               ,(my-capture-heading-template "%<%H:%M%#p> - %?")
               :time
               :empty-lines-after 1
               :kill-buffer t))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-journal-file-for-timestamp ()
  "Asks user for a specific timestamp and returns the journal file for it. It also
position the cursor on the correct place for a new entry, and adjust the capture
frame width to `fill-column' before start editing."
  (my-capture--adjust-frame)
  (my-journal/new-entry t nil 'my-capture-timestamp))
#+end_src

**** Tasks

#+begin_src text :tangle no
[t]     ● General task
[d]     ● Task with deadline
[s]     ● Scheduled task
--------------------------------------------------------------------------------
[q]     ● Abort
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("t"  ,(my-capture-description :text "Tasks" :icon `(inbox . ,(doom-color 'orange 256))))
              ("tt" ,(my-capture-description :text "New task" :icon `(inbox . ,(doom-color 'green 256)))
               plain (file+function +org-tasks-file my-capture-position-cursor)
               ,(my-capture-heading-template "TODO %?")
               :olp ("To do /this week/")
               :empty-lines-after 1
               :kill-buffer t)
              ("td" ,(my-capture-description :text "Task with deadline" :icon `(timer . ,(doom-color 'yellow 256)))
               plain (file+function +org-tasks-file my-capture-position-cursor)
               ,(my-capture-heading-template "TODO %?\nDEADLINE: %(my-capture-time-read)")
               :read-time t
               :read-time-label "Deadline"
               :olp ("Time bound tasks")
               :empty-lines-after 1
               :kill-buffer t)
              ("ts" ,(my-capture-description :text "Scheduled task" :icon `(calendar . ,(doom-color 'orange 256)))
               plain (file+function +org-tasks-file my-capture-position-cursor)
               ,(my-capture-heading-template "TODO %?\nSCHEDULED: %(my-capture-time-read)")
               :read-time t
               :read-time-label "Start time"
               :olp ("Time bound tasks")
               :empty-lines-after 1
               :kill-buffer t))))
#+end_src

**** Contacts

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
;; (after! org-capture
;;   (appendq! org-capture-templates
;;             `(("c" ,(my-capture-description :text "Contact" :icon `(contact-add . ,(doom-color 'yellow 256)))
;;                plain (file+function +org-contacts-file my-capture-position-cursor)
;;                ,(my-capture-heading-template "* %|contact|\n\n")
;;                :empty-lines-after 1
;;                :kill-buffer t))))
#+end_src

#+caption: $DOOMDIR/share/capture/org-mode/capture-contact
#+begin_src snippet :tangle share/capture/org-mode/capture-contact
# name: New Contact
# key: capture-contact
# --
${1:Name}
:PROPERTIES:
:TYPE: ${2:$$(yas-auto-next (yas-choose-value '(" person" " company")))}
:${2:$(if (string= yas-text " company") "CONTACT" "COMPANY")}: ${3:Name}
${2:$(if (string= yas-text " company") ":TITLE: \n" "")}:PHONE: ${4:phone}
${2:$(if (string= yas-text " company") "" ":PHONE-W: \n")}:EMAIL: ${5:email}
:URL:
:ADDRESS:
:PICTURE:
:BIRTHDAY:
:LAST_READ_MAIL:
:END:

$0
#+end_src

**** Project notes

#+begin_src text :tangle no
[t]     ● New task
[d]     ● Quick note
[s]     ● New changelog
--------------------------------------------------------------------------------
[q]     ● Abort
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org-capture
  (appendq! org-capture-templates
            `(("p"  ,(my-capture-description :text "Projct" :icon `(project . ,(doom-color 'violet 256))))
              ("pt" ,(my-capture-description :text "New task" :icon `(checklist . ,(doom-color 'green 256)))
               entry (file+headline my-capture-project-notes-file-wrapper "Tasks")
               ,(concat "* TODO %?\n"
                        "%(my-capture-template-selection)")
               :empty-lines-after 1
               :kill-buffer t)
              ("pn" ,(my-capture-description :text "Quick note" :icon `(postit . ,(doom-color 'yellow 256)))
               entry (file+headline my-capture-project-notes-file-wrapper "Notes")
               ,(concat "* %U %?\n"
                        "%(my-capture-template-selection)")
               :empty-lines-after 1
               :kill-buffer t)
              ("pc" ,(my-capture-description :text "New changelog" :icon `(list . ,(doom-color 'violet 256)))
               item (function my-capture-project-changelog-file-with-headings)
               "- %?"
               :prepend t
               :empty-lines-before 1
               :kill-buffer t))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-project-notes-file-wrapper ()
  "Returns an org file to hold notes and tasks for the current
  project."
  (my-capture--adjust-frame)
  (+org-capture-project-notes-file))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-capture-project-changelog-file-with-headings ()
  (let ((entry-path (+org-capture-project-changelog-file))
        (org-complex-heading-regexp-format "\\* %s"))
    (unless (file-exists-p entry-path)
      (make-empty-file entry-path t))
    (find-file entry-path)
    (goto-char (point-min))
    (my-capture--ensure-heading-prepend (my-capture-project-target-heading))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture-project-target-heading ()
  `("Unreleased" ,(format-time-string "%A, %B %-e, %Y")))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--ensure-heading-prepend (headings &optional initial-level)
  (if (not headings)
      (widen)
    (let ((initial-level (or initial-level 1)))
      (if (and (re-search-forward (format org-complex-heading-regexp-format
                                          (regexp-quote (car headings)))
                                  nil t)
               (= (org-current-level) initial-level))
          (progn
            (message "Found heading '%s'" (car headings))
            (beginning-of-line)
            (org-narrow-to-subtree))
        (message "Could not find heading '%s'" (car headings))
        (if (= initial-level 1)
            (goto-char (point-max))
          (end-of-line))
        (unless (and (bolp) (eolp)) (insert "\n"))
        (insert (make-string initial-level ?*) " " (car headings) "\n"))
      (my-capture--ensure-heading-prepend (cdr headings) (1+ initial-level)))))
#+end_src

**** Finalize capture templates

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defadvice! my-org-capture-select-template-prettier-a (&optional keys)
  "Select a capture template, in a prettier way than default Lisp programs can
force the template by setting KEYS to a string."
  :override 'org-capture-select-template
  (let ((org-capture-templates
         (or (org-contextualize-keys (org-capture-upgrade-templates org-capture-templates)
                                     org-capture-templates-contexts)
             '(("t" "Task"
                entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               (propertize (if (+org-capture-frame-p)
                               (concat (s-center 50 "Doom Capture") "\n"
                                       (s-center 50 "━━━━━━━━━━━━"))
                             (concat "Doom Capture\n"
                                     "━━━━━━━━━━━━"))
                           'face 'font-lock-type-face)
               " "
               `(("q" ,(my-capture-description :text "Abort" :icon `(stop . ,(doom-color 'red 256)))))))))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defadvice! my-org-capture-mks-prettier-a (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string. There
should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\") This indicates that `a' is a
   prefix key for multi-letter selection, and that there are entries following
   with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first being
   the string of keys that lead to selecting it, and the second a short
   description string of the item.

The command will then make a temporary buffer listing all entries that can be
selected with a single key, and all the single key prefixes. When you press the
key for a single-letter entry, it is selected. When you press a prefix key, the
commands (and maybe further prefixes) under this key will be shown and offered
for selection.

TITLE will be placed over the selection in the temporary buffer, PROMPT will be
used when prompting for a key. SPECIALS is an alist with (\"key\"
\"description\") entries. When one of these is selected, only the bare key is
returned."
  :override 'org-mks
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (erase-buffer)
              (insert title "\n\n")
              (let ((original-evil-normal-state-cursor evil-normal-state-cursor)
                    (des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                (setq evil-normal-state-cursor (list nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) ""))))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (my-capture--item-entry k desc current t) "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (my-capture--item-entry k desc current) "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (my-capture--item-entry key
                                                      description
                                                      (when current
                                                        (s-repeat (length current) " "))
                                                      nil
                                                      'all-the-icons-red))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (my-capture--refresh-capture-frame)
                (let ((pressed (org--mks-read-key
                                allowed-keys prompt
                                (not (pos-visible-in-window-p (1- (point-max)))))))
                  (set-frame-name (alist-get 'name +org-capture-frame-parameters))
                  (setq evil-normal-state-cursor original-evil-normal-state-cursor)
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer
          (kill-buffer buffer))))))

#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--item-entry (key description &optional prefix parent-option-p key-face-extras)
  "Returns a string representing an Org Capture item with the given KEY and
DESCRIPTION.

PREFIX is the character sequences already pressed during the capture process.

If PARENT-OPTION-P is non-nil, it means the this entry has sub-entries and some
sort of indication should be displayed

The KEY-FACE-EXTRAS is one or more simbols to be added to the KEY face on the
entry."
  (let ((parent-option-p (when parent-option-p "›"))
        (prefix (when prefix (concat prefix " "))))
    (concat
     (when prefix (propertize prefix 'face 'font-lock-comment-face))
     (propertize key 'face (append '(bold) key-face-extras))
     (propertize (or parent-option-p " ") 'face 'font-lock-comment-face)
     "  " description (when parent-option-p "…"))))

#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
(defun my-capture--refresh-capture-frame ()
  "This function is called right after all the capture options were written in the
capture buffer."
  (when (+org-capture-frame-p)
    (let ((frame (selected-frame)))
    (set-frame-parameter frame 'left-fringe 30)
    (set-frame-parameter frame 'right-fringe 30)
    (set-frame-name " ")
    (set-frame-size frame
                    my-capture--menu-width
                    (+ (line-number-at-pos (point-max)) 3))
    (my-capture--reposition-frame)
    (message ""))))
#+end_src

*** Journal
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq my-journal-file-format "journal-%Y.org")

(defconst my-journal-file (expand-file-name (format-time-string my-journal-file-format)
                                              my-journal-directory))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package org-journal
  :defer t
  :config
  (setq org-journal-encrypt-journal nil
        org-journal-carryover-delete-empty-journal '(ask)
        org-journal-carryover-items "TODO=\"STRT\"|TODO=\"HOLD\"|TODO=\"WAIT\"|TODO=\"DELG\""
        org-extend-today-until 4
        org-journal-file-type 'yearly
        org-journal-enable-agenda-integration nil
        org-journal-file-format my-journal-file-format
        org-journal-date-format "%A, %B %-e, %Y"
        org-journal-time-format "%H:%M%#p - "
        org-journal-time-format-post-midnight "+%H:%M%#p - "
                            org-journal-file-header (concat "#+TITLE: Daily Journal for %Y (%Z)\n"
                                        "#+STARTUP: overview\n"
                                        "#+CATEGORY: journal\n"
                                        "\n"))

  (font-lock-add-keywords 'org-journal-mode my-org-font-lock-beautify-keywords)
  (set-window-buffer nil (current-buffer)))
#+end_src

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-journal/new-entry (&optional prefix add-header-p variable make-local)
  "Open a journal file and start a new entry. Without any arguments, this function
is equivalent to calling `(org-journal-new-entry t)'

With PREFIX argumant, request the journal timestamp to the user.

If ADD-HEADER-P is non-nil, fully create the new entry (this is equivalent
to `(not PREFIX)' on the `org-journal-new-entry').

VARIABLE is a string that, when set, will store the timestamp value selected by
the user. This function ignores this argument if PREFIX is nil.

When MAKE-LOCAL is a non-nil value, this function uses VARIABLE to create a
local variable. If PREFIX or VARIABLE is nil, this argument has no effect."
  (interactive "P")
  (when make-local
    (make-local-variable variable))
  (org-journal-new-entry (not add-header-p)
                         (when variable
                           (set variable
                                (when prefix
                                  (org-read-date t t nil "New entry"))))))
#+end_src

*** Zettelkasten

- https://tecosaur.github.io/emacs-config/config.html#basic-settings

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/depot/Dropbox/org/notes") "no" "packages.el")
(package! org-roam :disable t)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package org-roam
  :commands (org-roam-capture)
  :custom
  (org-roam-capture-templates
   '(("d" "default" plain (function org-roam-capture--get-point)
      "%?"
      :file-name "%(s-trim-right (shell-command-to-string \"uuidgen\"))"
      :head "#+TITLE: ${title}\n#+ROAM_TAGS: \n\n"
      :unnarrowed t)))
  (org-roam-capture-ref-templates
   '(("r" "ref" plain (function org-roam-capture--get-point)
      "\n#+BEGIN_QUOTE\n${selection}\n#+END_QUOTE\n\n%?\n\n* See Also\n\n- source :: ${ref}\n"
      :file-name "websites/%(s-trim-right (shell-command-to-string \"uuidgen\"))-${slug}"
      :head "#+TITLE: ${title}\n#+ROAM_TAGS: \n#+ROAM_KEY: ${ref}\n"
      :unnarrowed t))))

(after! org-roam
  (setq org-roam-link-title-format "✑ %s"
        org-roam-graph-extra-config '(("overlap" . "false"))
        org-roam-encrypt-files nil
        org-roam-directory my-notes-directory)

  (advice-add 'org-roam-dailies-capture-yesterday :filter-return #'+org-capture-open-frame-get-info-a)
  (advice-add 'org-roam-dailies-capture-today :filter-return #'+org-capture-open-frame-get-info-a)
  (advice-add 'org-roam-dailies-capture-tomorrow :filter-return #'+org-capture-open-frame-get-info-a)
  (advice-add 'org-roam-dailies-capture-date :filter-return #'+org-capture-open-frame-get-info-a))
#+end_src

*** Deft
TBD
#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq deft-directory my-notes-directory
      deft-strip-summary-regexp (concat "\\("
                                        "[\n\t]"                    ;; blank
                                        "\\|^#\\+[[:upper:]_]+:.*$" ;; org-mode metadata
                                        "\\)")
      deft-time-format "  %A, %B %e %Y (%H:%M)")

(add-hook! 'deft-mode-hook
  (defun my-deft-buffer-config-h ()
    (hl-line-mode 1)
    (setq-local evil-normal-state-cursor (list nil)
                evil-insert-state-cursor (list nil))))

(map! :after deft
      (:map deft-mode-map
       :i   "<escape>" #'kill-current-buffer
       :i   "C-c C-q"  #'kill-current-buffer
       :i   "C-j"      #'widget-forward
       :i   "C-k"      #'widget-backward))
#+end_src

*** Utilities

#+caption: $DOOMDIR/autoload/writing.el
#+begin_src emacs-lisp :tangle autoload/writing.el
;;;###autoload
(defun my-notes-add-action-item ()
  (interactive)
  (call-interactively '+org/insert-item-below)
  (insert "Action Items")
  (call-interactively 'org-insert-subheading)
  (insert "TODO "))
#+end_src 

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after org
      (:map org-mode-map
       :leader
       (:prefix ("n" . "notes")
        (:prefix ("i" . "notes-insert")
         :desc "Insert action items"  "a" #'my-notes-add-action-item))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! plantuml-mode
  :defer t
  :init
  (setq plantuml-jar-path "/usr/local/var/homebrew/linked/plantuml/libexec/plantuml.jar"
        org-plantuml-jar-path plantuml-jar-path)
  (set-popup-rule! "^\\*PLANTUML" :size 0.4 :side 'right :select nil :ttl 0))
#+end_src

** TODO Other modes
Although my writing will be exclusive in =org-mode=, I'm still interaction with other writing modes, and I want the experience using those modes to get /as close as possible/ to the experience with =org=mode=.

*** Markdown

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq markdown-split-window-direction 'right
      markdown-list-item-bullets '("•" "‣" "⁍")
      markdown-blockquote-display-char `(,(propertize "▌" 'face '(:inherit markdown-blockquote-face
                                                                  :slant normal))
                                         ,(propertize "┃" 'face '(:inherit markdown-blockquote-face
                                                                  :slant normal))
                                         ">")
      markdown-header-scaling t
      markdown-header-scaling-values (list (face-attribute 'my-headline-1 :height)
                                           (face-attribute 'my-headline-2 :height)
                                           (face-attribute 'my-headline-3 :height)
                                           (face-attribute 'my-headline-4 :height)
                                           (face-attribute 'my-headline-5 :height)
                                           (face-attribute 'my-headline-6 :height)))

(my-typography-reset (cl-loop for i from 1 to 6 collect (intern (format "markdown-header-face-%d" i))))
(my-typography-reset 'markdown-code-face)

(custom-set-faces!
  `(markdown-header-face-1 :inherit outline-1 :weight unspecified :extend unspecified)
  `(markdown-header-face-2 :inherit outline-2 :weight unspecified :extend unspecified)
  `(markdown-header-face-3 :inherit outline-3 :weight unspecified :extend unspecified)
  `(markdown-header-face-4 :inherit outline-4 :weight unspecified :extend unspecified)
  `(markdown-header-face-5 :inherit outline-5 :weight unspecified :extend unspecified)
  `(markdown-header-face-6 :inherit outline-6 :weight unspecified :extend unspecified)
  '(markdown-code-face :inherit my-default-mono :weight unspecified :extend unspecified)
  `(markdown-header-face :inherit unspecified)
  `(markdown-list-face :foreground unspecified :inherit org-list-dt))

(add-hook! (markdown-mode gfm-mode)
  (defun my-markdown-buffer-config-h ()
    (+zen/toggle 1)
    (variable-pitch-mode 1)
    (markdown-toggle-markup-hiding 1)))
#+end_src

* Development
TBD

** TODO Requirements

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! lsp-ui
  :defer t
  :custom
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable t))
#+end_src

** TODO Common configuration
TBD

*** Version control system

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! magit-todo :defer t)
#+end_src

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(if (getenv "GITHUB_WORKFLOW")
    (package! gitmoji
      :recipe (:host github
               :repo "Townk/gitmoji"))
  (package! gitmoji
    :recipe (:local-repo "~/workplace/personal/emacs/gitmoji")))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! gitmoji
  :commands (gitmoji-insert gitmoji-select)
  :init
  (setq gitmoji-insert-utf8-emoji t
        gitmoji-display-utf8-emoji t))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! magit
  ;; (remove-hook 'server-switch-hook 'magit-commit-diff)
  (add-hook 'git-commit-setup-hook 'my-git-commit-buffer-config-h))
#+end_src

#+caption: $DOOMDIR/autoload/development.el
#+begin_src emacs-lisp :tangle autoload/development.el
;;;###autoload
(defun my-git-commit-buffer-config-h ()
  "Configure the Git Commit Message buffer."
  (setq-local display-fill-column-indicator-column 72)
  (display-fill-column-indicator-mode 1)
  (goto-char (point-min))
  (evil-append-line 1)
  (yas-expand-snippet (yas-lookup-snippet "commit-message" 'git-commit-mode)))
#+end_src

#+caption: $DOOMDIR/snippets/git-commit-mode/commit-message
#+begin_src snippet :tangle snippets/git-commit-mode/commit-message
# name: commit-message
# key: msg
# --
${1:$$(unless (or yas-moving-away-p yas-modified-p)
              (yas-auto-next
                (condition-case nil
                    (or (gitmoji-select) "")
                  ('quit ""))))}${2:Subject}

;-------------------------------------------------|
;       Do not pass this column on the subject -> |
;-------------------------------------------------|
${3:`"## Changes Description\n"`}$0
; 1. Separate subject from body with a blank line
; 2. Limit the subject line to 50 characters
; 3. Capitalize the subject line
; 4. Do not end the subject line with a period
; 5. Use the imperative mood in the subject line
; 6. Wrap the body at 72 characters
; 7. Use the body to explain what and why vs. how
#+end_src

*** Comments
TBD

#+caption: $DOOMDIR/autoload/development.el
#+begin_src emacs-lisp :tangle autoload/development.el
;;;###autoload
(defadvice! my-comment-and-next-line-a (func &rest args)
  :around 'evilnc-comment-or-uncomment-lines
  (let ((no-selection-p (not (region-active-p))))
    (apply func args)
    (when no-selection-p
      (next-line)
      (goto-char (point-at-bol))
      (skip-chars-forward " \t\r"))))
#+end_src

** TODO Lisp
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq emacs-lisp-docstring-fill-column 80)
#+end_src

** TODO Shell script
** TODO Python
** TODO Ansible
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(def-project-mode! +ansible-yaml-mode
  :modes '(yaml-mode)
  :add-hooks '(ansible ansible-auto-decrypt-encrypt ansible-doc-mode)
  :files (and "ansible.cfg"
              (or "main.yaml"
                  "main.yml"
                  "tasks/main.yaml"
                  "tasks/main.yml")))
#+end_src

** TODO Javascript/TypeScript
** TODO C/C++
** TODO Swift
** TODO Kotlin
** TODO Java

* Non-editor features
TBD

** TODO Requirements
** TODO File management
Before we start configuring the target packages for this section (=dired= and =eshel=), I want to make some small adjustments to Treemacs. Although it is not a full blown file manager, it is a sort of a file manager for my projects, so it fits in this section.

The first thing I like to do, is to unpin Treemacs and let Doom use the latest version of it:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(unpin! treemacs)
#+end_src

The next change is to use our custom =my-default-ui= font face. I have to replace the entire ~doom-themes-enable-treemacs-variable-pitch-labels~ function with a version that uses my custom font instead. To do that, I'll use Emacs advices:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-themes-enable-treemacs-variable-pitch-labels-a (&rest _)
  "This advice changes the treemacs variable pitch font to one without serif so
the UI looks more polished."
  :override #'doom-themes-enable-treemacs-variable-pitch-labels
  (when doom-themes-treemacs-enable-variable-pitch
    (dolist (face '(treemacs-root-face
                    treemacs-git-unmodified-face
                    treemacs-git-modified-face
                    treemacs-git-renamed-face
                    treemacs-git-ignored-face
                    treemacs-git-untracked-face
                    treemacs-git-added-face
                    treemacs-git-conflict-face
                    treemacs-directory-face
                    treemacs-directory-collapsed-face
                    treemacs-file-face
                    treemacs-tags-face))
      (let ((faces (face-attribute face :inherit nil)))
        (set-face-attribute
         face nil :inherit
         `(my-default-ui ,@(delq 'unspecified (if (listp faces) faces (list faces)))))))))
#+end_src

By default, Treemacs will stay opened after you select a file to visit. Personally I don't like this, I rather have Treemacs closing when I select a file.

In order to help me achieve my desired behavior, I'll  create another /autoload/ function that I'll call when I select a file:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-visit-node-and-close-h (&optional arg)
  "Closes treemacs window after selecting a file to visit."
  (treemacs-visit-node-default arg)
  (delete-window (treemacs-get-local-window)))
#+end_src

We can now, configure Treemacs properly:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! treemacs
#+end_src

First we need to tell Treemacs to use the new autoload function when I press =<ENTER>= on a file:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (treemacs-define-RET-action 'file-node-open #'my-treemacs-visit-node-and-close-h)
  (treemacs-define-RET-action 'file-node-closed #'my-treemacs-visit-node-and-close-h)
#+end_src

Then, I like Treemacs to collapse directory into one when possible:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq treemacs-collapse-dirs (if (executable-find "python3") 3 0))
#+end_src

https://andreyorst.gitlab.io/posts/2020-05-01-dynamic-title-for-treemacs-workspace/

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-buffer-config-h ()
  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (face-remap-add-relative 'header-line
                             :background bg :foreground fg
                             :box `(:line-width ,(/ my-line-pixel-height 2) :color ,bg)))
  (setq header-line-format
        '((:eval
           (concat
            " ☰ "
            (propertize (s-titleize (persp-current-name)) 'face 'my-ui-window-header))))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (add-hook 'treemacs-mode-hook #'my-treemacs-buffer-config-h)
#+end_src

And finally, we can close our Treemacs configuration

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  )
#+end_src

I also like to make sure it behaves as expected if I use the mouse:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after treemacs
  (:map treemacs-mode-map
   [mouse-1] #'treemacs-single-click-expand-action))

 (:after treemacs-evil
  (:map evil-treemacs-state-map
   "C-h" #'evil-window-left
   "C-l" #'evil-window-right))

 (:after cfrs
  (:map cfrs-input-mode-map
   :n [escape] #'cfrs-cancel)))
#+end_src

Treemacs offers a function that adds the current project if it is not on the workspace. That is a nice feature, but because I use workspaces heavily, the fact that this function does not /remove/ projects that do not belong to this workspace bothers me, so I  wrote this advice to do the dirty work for me:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-treemacs-add-and-display-current-project-a ()
  "Open treemacs with current project. This function removes any project that is
not the current one."
  :override #'treemacs-add-and-display-current-project
  (interactive)

  (cl-dolist (p (treemacs-workspace->projects (treemacs-current-workspace)))
    (unless (string= (doom-project-name) (treemacs-project->name p))
      (treemacs-do-remove-project-from-workspace p t)))

  (when (treemacs-workspace->is-empty?)
      (treemacs-do-add-project-to-workspace (doom-project-root) (doom-project-name)))

  (treemacs-select-window)
  (treemacs-pulse-on-success))
#+end_src

And to finalize the Treemacs configuration, let's make it respect my window navigation keys:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangleautoload/files.el
;;;###autoload
(defun my-dired/toggle-git-mode ()
  "Toggle `dired-git-info-mode' in git repos."
  (interactive)
  (when (and (not (file-remote-p default-directory))
             (locate-dominating-file "." ".git"))
    (call-interactively 'dired-git-info-mode)))

;;;###autoload
(defun my-dired/open-directory ()
  "Enters in the directory at point. If the cursor is not on a directory, do
nothing."
  (interactive)
  (when (file-directory-p (dired-get-file-for-visit))
    (dired-find-file)))

;;;###autoload
(defun my-dired/mac-quick-view ()
  "Invoke the macOS Quiclview on the file under point."
  (interactive)
  (shell-command (concat "qlmanage -p \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))

;;;###autoload
(defun my-dired/widen-or-quit-all ()
  "If `dired-narow' is on, revert to the normal view. If there is no active
narrow, quit Dired."
  (interactive)
  (if (buffer-modified-p)
      (revert-buffer)
    (mapc (lambda (buf)
            (let ((win (get-buffer-window buf)))
              (unless (append (window-prev-buffers win) (window-prev-buffers win))
                (delete-window win))
              (kill-buffer buf)))
          (doom-buffers-in-mode 'dired-mode))))

;;;###autoload
(defun my-dired/narrow (narrow-func)
  "Start a dynamic narrowing of files in current view."
  (interactive
   (list (if current-prefix-arg
             'dired-narrow-fuzzy
           'dired-narrow-regexp)))
  (call-interactively narrow-func))

;;;###autoload
(defun my-dired/yank-absolute-path ()
  "Copy the absolute path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill 0))

;;;###autoload
(defun my-dired/yank-relative-path ()
  "Copy the relative path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill))

;;;###autoload
(defun my-dired/open-externally ()
  "Open file with application defined by OS."
  (interactive)
  (shell-command (concat "open \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))

;;;###autoload
(defun my-dired/reveal-on-finder ()
  "Show current file in Finder."
  (interactive)
  (shell-command (concat "open --reveal \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))

(defun my-dired-marked-file-p ()
  "Return non-nil if we have marked file at point."
  (dired-file-marker (dired-get-file-for-visit)))

;;;###autoload
(defun my-dired/toggle-mark (&optional args)
  "Toggle mark of file at point."
  (interactive)
  (if (my-dired-marked-file-p)
      (dired-unmark 1)
    (dired-mark 1)))

;;;###autoload
(defun my-dired/open-split-right ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-right)
                           'window)))

;;;###autoload
(defun my-dired/open-split-bellow ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-below)
                           'window)))
#+end_src

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! dired-collapse)
(package! dired-narrow)
;; (package! sunrise-commander)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! dired
  (setq
        auto-revert-verbose nil
        dired-dwim-target t
        dired-listing-switches "-lAhvFoG --group-directories-first"
        dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$\\|^.DS_STORE$\\|^.projectile$"
        dired-recursive-copies '(always)
        dired-recursive-deletes '(top)
        dired-use-ls-dired t
        global-auto-revert-non-file-buffers t
        insert-directory-program "gls"
        ))

(use-package! dired-collapse :commands (dired dired-noselect))
(use-package! dired-narrow :after (dired dired-noselect))
;; (add-hook 'kill-buffer-hook '+doom--delete-window-if-only-buffer)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after dired
      (:map dired-mode-map
       :ne "t"        nil
       :ne "y"        nil
       :ne "c"        nil
       :ne "o"        nil
       :ne "m"        nil
       :ne "/"        #'my-dired/narrow
       :ne "<escape>" #'my-dired/widen-or-quit-all
       :ne "q"        #'my-dired/widen-or-quit-all
       :ne "RET"      #'dired-find-file
       :ne "TAB"      #'my-dired/open-directory
       :ne "<tab>"    #'my-dired/open-directory
       :ne "l"        #'my-dired/open-directory
       :ne "h"        #'dired-up-directory
       :ne "U"        #'dired-up-directory
       :ne "R"        #'dired-do-rename
       :ne "d"        #'dired-do-delete
       :ne "x"        #'my-dired/toggle-mark
       (:prefix ("t" . "toggle")
        :desc "Toggle collapsed dirs" :ne "c" #'dired-collapse-mode
        :desc "Toggle git info"       :ne "g" #'my-dired/toggle-git-mode
        :desc "Toggle hidden files"   :ne "h" #'dired-omit-mode
        :desc "Toggle all marks"      :ne "m" #'dired-toggle-marks)
       (:prefix ("y" . "yank")
        :desc "Copy absolut path"     :ne "a" #'my-dired/yank-absolute-path
        :desc "Copy file"             :ne "f" #'dired-do-copy
        :desc "Copy with regexp"      :ne "r" #'dired-do-copy-regexp
        :desc "Copy relative path"    :ne "y" #'my-dired/yank-relative-path)
       (:prefix ("c" . "create")
        :desc "Create empty file"     :ne "f" #'dired-do-touch
        :desc "Create directory"      :ne "d" #'dired-create-directory
        :desc "Create project"        :ne "p" #'xxx)
       (:prefix ("o" . "open")
        :desc "Open no split"         :ne "o" #'dired-find-alternate-file
        :desc "Quick view"            :ne "p" #'my-dired/mac-quick-view
        :desc "Reveal on Finder"      :ne "f" #'my-dired/reveal-on-finder
        :desc "Open vertically"       :ne "s" #'my-dired/open-split-bellow
        :desc "Open horizontally"     :ne "v" #'my-dired/open-split-right
        :desc "Open externally"       :ne "x" #'my-dired/open-externally)
       (:prefix ("m" . "mark")
        :ne "h" nil
        :desc "Mark directories"  :ne "d" #'dired-mark-directories
        :desc "Mark extension"    :ne "e" #'dired-mark-extension
        :desc "Mark hidden files" :ne "h" #'dired-mark-omitted
        :desc "Mark with regexp"  :ne "r" #'dired-mark-files-regexp
        :desc "Mark subdir files" :ne "s" #'dired-mark-omitted
        :desc "Unmark all files"  :ne "u" #'dired-unmark-all-files
        :desc "Remove all marks"  :ne "U" #'dired-unmark-all-marks
        :desc "Mark executables"  :ne "x" #'dired-mark-executables)))
#+end_src

** TODO Project management
Projectile is a great package. It usually provides more features that one particular user would need. But I still want to tweak it to make it behave more according my expectations.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! projectile
#+end_src

To make =projectile= work with =selectrum=, we need to tell it to use the default Emacs completion system:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq projectile-ignored-projects `("~/"
                                      "/tmp"
                                      ,(expand-file-name "straight/repos" doom-local-dir)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq projectile-completion-system 'default)
#+end_src

Doom sets a function to run when we open a project with =projectile=, but that function is not calling any /open file/ function for us. Let's create our own version of such function and help projectile to do the appropriate thing when we open a project.

The actions I expect are:

- Check if the project has one of the recognized files and open it, in this order (we should look for four extensions on each one of the files, also in this order: =.org=, no extension, =.md=, and =.rst=):
  + =CHANGELOG=
  + =NEWS=
  + =README=
- If none of the recognizable files is present, run ~project-find-file~;

Let's create such function as an /autoload/ function:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-after-switch-project-action-h ()
  "A project first action to execute when we switch our current project."
  (let ((file (file-exists-p! (or "README.rst"
                                  "README.md"
                                  "README"
                                  "README.org"
                                  "NEWS.rst"
                                  "NEWS.md"
                                  "NEWS"
                                  "NEWS.org"
                                  "CHANGELOG.rst"
                                  "CHANGELOG.md"
                                  "CHANGELOG"
                                  "CHANGELOG.org"))))
    (if file
        (find-file-existing file)
      (projectile-find-file))))
#+end_src

And attach it to the =projectile= hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq projectile-switch-project-action #'my-after-switch-project-action-h)
#+end_src

As usual, don't forget to close the =after!= sexp:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
   )  ;; after! projectile
#+end_src

** TODO Terminal
In general, I really like the setup Doom has for the terminal. There are 3 things I like to add there.

One are some aliases that I'm used to use when working on the terminal:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! eshell
  (set-eshell-alias!
   "d"     "dired $1"
   "edit"  "find-file-other-window $1"
   "em"    "find-file-other-window $1"
   "emacs" "find-file-other-window $1"
   "f"     "find-file $1"
   "gc"    "magit-commit $1"
   "gl"    "(call-interactively 'magit-log-current)"
   "gst"   "magit-status $1"
   "ls"    "exa --group-directories-first --color always -F $1"
   "la"    "exa --group-directories-first --color always -F -a $1"
   "ll"    "exa --group-directories-first --color always -F -l -h --git $1"
   "lla"   "exa --group-directories-first --color always -F -a -l -h --git $1"
   "rg"    "rg --color=always $*"
   "up"    "eshell-up $1"
   "pk"    "eshell-up-peek $1"
   "vi"    "find-file-other-window $1"
   "vim"   "find-file-other-window $1"))
#+end_src

Two is the window navigation mapping:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after eshell
      (:map eshell-mode-map
       :in "C-h" #'evil-window-left
       :in "C-j" #'evil-window-down
       :in "C-k" #'evil-window-up
       :in "C-l" #'evil-window-right))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*doom:\\(?:v?term\\|e?shell\\)-popup"
  :slot 2   :vslot -1     :side 'bottom  :width 110 :height 0.4
  :select t :modeline nil :autosave nil  :ttl nil   :quit nil)
#+end_src

And three is to fix =magit-status=. When I'm on the terminal, if I open =magit-status=, everything works as expected, but when I exit back to the terminal, Emacs switch the buffer on my terminal window to something else.

The ideal behavior would be to any app launch from the terminal to take over eshell's window until done. Then, revert back to the terminal.

I like to have a hint of the next possible completion while I'm working on shell. Zsh and Fish have great plugins for such feature, so I decided to add one for eshell as well:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! esh-autosuggest)
#+end_src

The only configuration we need to get this mode working, is to let Emacs enable it when =eshell-mode= is up.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! esh-autosuggest
  :defer t
  :hook ((eshell-mode . esh-autosuggest-mode)))
#+end_src

** TODO Emails

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
#+end_src

** TODO Calendars

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst +work-calendar-personal (expand-file-name "personal.org" my-calendars-directory)
  "File path for my personal calendar")

(defconst +work-calendar-family (expand-file-name "family.org" my-calendars-directory)
  "File path for my personal calendar")

(defconst +work-calendar-work (expand-file-name "work.org" my-calendars-directory)
  "File path for my personal calendar")

(defconst +org-calendars-files (list +work-calendar-personal
                                     +work-calendar-family
                                     +work-calendar-work)
  "List of directories to find files with appointment events (calendar)")
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defconst +doom-calendar-color-table (make-hash-table :test #'equal)
  "A hash table to hold an association between a calendar name (in our org world,
this is the event's category), and its defined color.")

(puthash "work"     '(:color "#a67a63" :bg "#4f3426" :fg "#ffc8a9") +doom-calendar-color-table)
(puthash "personal" '(:color "#19adf8" :bg "#17445d" :fg "#a9e3ff") +doom-calendar-color-table)
(puthash "family"   '(:color "#cd73e1" :bg "#45285c" :fg "#f1aeff") +doom-calendar-color-table)

;;;###autoload
(defun my-work-calendar-color (name &optional prop)
  "Returns a string representing the color for PROP for the calendar with the
given NAME.

If color is nil, this function uses the property `:color'"
  (plist-get (gethash name +doom-calendar-color-table) (or prop :color)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq +calendar-open-function #'my-work/open-calendar)

(map! :leader :prefix ("o" . "open")
      :desc "Open calendar" :nvm "c" #'=calendar)
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-work/open-calendar ()
  "TODO"
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-file-source "Personal" +work-calendar-personal (my-work-calendar-color "personal"))
    (cfw:org-create-file-source "Family" +work-calendar-family (my-work-calendar-color "family"))
    (cfw:org-create-file-source "Work" +work-calendar-work (my-work-calendar-color "work"))
    )))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! calfw
  (custom-theme-set-faces! 'doom-one
    `(cfw:face-today-title :foreground "#FFFFFF"
                           :background "#2E475E")
    `(cfw:face-today :foreground ,(doom-color 'fg)
                     :background "#1c2b39")
    `(cfw:face-grid :foreground ,(doom-color 'base4 256))
    `(cfw:face-select :foreground ,(doom-darken 'number 256)
                      :background ,(doom-lighten 'number 256))
    `(cfw:face-holiday :foreground ,(doom-color 'green 256))
    `(cfw:face-saturday :foreground ,(doom-color 'red 256))
    `(cfw:face-sunday :foreground ,(doom-color 'red 256)))

  (map! :map cfw:calendar-mode-map
        :e "q" #'+calendar/quit))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-work-calendar-open-a ()
  "Activate (or switch to) `calendar' in its workspace."
  :override '=calendar
  (interactive)
  (+workspace-switch "Calendar" t)
  (doom/switch-to-scratch-buffer)
  (+calendar--init)
  (+workspace/display))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-work-calendar-quit-a ()
  "Activate (or switch to) `calendar' in its workspace."
  :override '+calendar/quit
  (interactive)
  (+workspace/delete "Calendar"))
#+end_src

** TODO Contacts
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst +org-contacts-file (expand-file-name "contacts.org" my-agenda-directory)
  "Path to the org file that will store all contacts.")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
;; (use-package! org-contacts
;;   :after (org-capture)
;;   :init
;;   (setq org-contacts-icon-property "PICTURE"
;;         org-contacts-icon-use-gravatar t))
#+end_src

** TODO Time Management

- Triage :: This process is to mark done tasks as done, and adjust any deadlines or other information on my tasks:
  + Daily :: Should be a quick 5 min check on the tasks done during the day. I will use this time to also add unexpected tasks on my list so I can have a more accurate record of my work day;
  + Weekly :: Should be a more in-depth review, where I will evaluate if I need to change or amend any of the tasks I'm tracking. This process shouldn't take more than 30 minutes;

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst +org-tasks-file (expand-file-name "todo.org" my-tasks-directory)
  "Path to the org file that will store all habits.")


(defconst +org-habits-file (expand-file-name "habits.org" my-agenda-directory)
  "Path to the org file that will store all habits.")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org
  (setq org-archive-location (concat org-directory "/.archives/%s::datetree/* Archived From %s")
        org-archive-tag "ARCHIVED"
        org-log-done t
        org-todo-keywords '((sequence
                             "TODO(t)"  ; This task needs to be done.

                             "NEXT(n)"  ; I committed to work on this task next. This can be used to
                                        ; plan my next day, or to indicate in a project the next
                                        ; logical step.

                             "STRT(s)"  ; This task is actively in progress. Ideally you only have
                                        ; one task marked as started, but in some cases you can
                                        ; start a task, and while you wait for something to
                                        ; complete, you can start another task.

                             "WAIT(w)"  ; This task is waiting some external condition to happen,
                                        ; like waiting for an authorization, waiting for account to
                                        ; be created, etc.

                             "HOLD(h)"  ; This task is paused. This state can mean many different
                                        ; things. A task can be paused because I simply don't want
                                        ; to continue doing it, or it is paused because I want to
                                        ; make sure I understand I shouldn't be work on this task.

                             "DELG(g)"  ; This task is delegated to someone else. Usually, a
                                        ; delegated task has a property indicating to whom it is
                                        ; delegated and when is the tentative ETA. This state is not
                                        ; considered final because I want to follow up with the
                                        ; person about the outcome.
                             "|"
                             "DONE(d)"  ; Task successfully completed

                             "KILL(k)"  ; Task was cancelled, aborted or is no longer applicable,
                                        ; but I want to keep it as a record instead of simply
                                        ; remove it from the file.
                             ))
        org-todo-keyword-faces '(("STRT" . +org-todo-active)
                                 ("DELG" . +org-todo-active)
                                 ("WAIT" . +org-todo-onhold)
                                 ("HOLD" . +org-todo-onhold))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-org-agenda-buffer-config-h ()
  (evil-window-set-width 100)
  (doom-themes-hide-modeline)
  ;; (variable-pitch-mode -1)
  (setq-local wrap-prefix (s-repeat +org-agenda--wrap-prefix " "))
  (setq writeroom-width 65)
  (+zen/toggle 1)
  (visual-line-mode 1)
  (tab-line-mode -1)
  ;; (hl-line-mode -1)
  (when (not (= text-scale-mode-amount 1))
    (setq-local text-scale-mode-amount 1)
    (text-scale-mode 1)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-org-agenda-setup-time-grid-h ()
  "Set different line spacing based on clock time duration."
  (let (first-item)
    (save-excursion
      (let (pos duration curr-time blocked-time marker)
        (goto-char (point-min))

        (while (setq pos (next-single-property-change (point) 'time-of-day))
          (goto-char pos)
          (setq curr-time (org-get-at-bol 'time-of-day))
          (when (and (not (equal pos (point-at-eol)))
                     curr-time)
            (if (setq duration (org-get-at-bol 'duration))
                (progn
                  (unless first-item (setq first-item pos))
                  (setq blocked-time (max (+ curr-time (* (/ duration 60.0) 100.0))
                                          (or blocked-time 0)))

                  (if (> (+ (point-at-bol) 71) (point-at-eol))
                      (progn
                        (goto-char (point-at-eol))
                        (insert-char #x20 (- 71 (- (point-at-eol) (point-at-bol))) t))
                    (when (< (+ (point-at-bol) 69) (point-at-eol))
                      (goto-char (+ (point-at-bol) 69))
                      (delete-region (point) (point-at-eol))
                      (insert-char ?… 1 t)
                      (insert-char #x20 1 t)))

                  (remove-text-properties (point-at-bol) (point-at-eol) '(mouse-face nil))

                  (let* ((line-height (if (< duration 15) 1.0 (+ 0.5 (/ duration 30))))
                         (block-start (+ (point-at-bol) (- +org-agenda--category-length 1)))
                         (block-end (+ block-start 59))
                         (ov (make-overlay (point-at-bol) (1+ (point-at-eol))))
                         (color-ov (make-overlay block-start block-end))
                         (mouse-ov (make-overlay block-start (point-at-eol)))
                         (cal (org-get-at-bol 'org-category)))
                    (when (setq marker (org-get-at-bol 'org-marker))
                      (add-text-properties (point-at-bol)
                                           (point-at-eol)
                                           `(org-target-file ,(cons
                                                               (buffer-file-name (marker-buffer marker))
                                                               (marker-position marker)))))

                    (overlay-put ov 'priority 1010)
                    (overlay-put ov 'line-height line-height)
                    (overlay-put ov 'line-spacing (1- line-height))
                    (overlay-put color-ov 'priority 1020)
                    (overlay-put color-ov 'face `(:background ,(my-work-calendar-color cal :bg)
                                                  :foreground ,(my-work-calendar-color cal :fg)
                                                  :box (:line-width -2 :color ,(doom-color 'bg))))
                    (overlay-put mouse-ov 'priority 1030)
                    (overlay-put mouse-ov 'mouse-face `(:background ,(my-work-calendar-color cal)
                                                        :foreground "white"
                                                        :box (:line-width -2 :color ,(doom-color 'bg))))))
              (when (< curr-time (or blocked-time -1))
                (kill-whole-line)
                (previous-line)))))))
    (when first-item
      (goto-char first-item))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-org-agenda-reset-font-a (&rest _)
  "Reset text scale before running `org-agenda-redo' to prevent messing with
layout."
  :before 'org-agenda-redo
  (setq-local text-scale-mode-amount 0)
  (text-scale-mode -1))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst +org-agenda--category-length 14
  "The length of the space categories occupy on org-agenda")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst +org-agenda--wrap-prefix (+ +org-agenda--category-length 5)
  "Length that a wrapped text should indent on org-agenda. This
length is the `+org-agenda--category-length' plus 5 characters to
account for the TODO word plus one space.")
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! org
  (setq org-agenda-block-separator " "
        org-agenda-compact-blocks nil
        org-agenda-current-time-string "◀- now - - - - - - - - - - - - - - - - - - -"
        org-agenda-files  (append (list +org-tasks-file my-journal-file) +org-calendars-files)
        org-agenda-include-deadlines t
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-agenda-time-grid '((daily today require-timed remove-match)
                               (700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800)
                               "······"
                               "╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌")
        org-agenda-window-setup 'other-window))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-contain-buffer-p (lst buf)
  "Return t if th given BUF is in the given LST.

This function searches the buffer in all nested lists containd in LST."
  (unless (not lst)
    (if (seqp lst)
        (seq-some (lambda (elm) (my-contain-buffer-p elm buf)) lst)
      (eq lst buf))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-bring-buffer-to-front (buffer-or-name)
  "Make sure buffer is visible on its window.

BUFFER-OR-NAME is the buffer to look for.

Return t if the buffer moved to front."
  (when-let ((buf (when buffer-or-name (get-buffer buffer-or-name)))
             (win (seq-find (lambda (window)
                              (seq-some (lambda (buf-list) (my-contain-buffer-p buf-list buf))
                                        (append (mapcar #'car (window-prev-buffers window))
                                                (list (window-buffer window))
                                                (window-next-buffers window))))
                            (window-list))))
    (set-window-buffer win buf t)
    t))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-bring-org-agenda-to-front-h ()
  (when (my-bring-buffer-to-front org-agenda-buffer)
    (my-org-agenda-buffer-config-h)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  `(org-agenda-current-time :foreground ,(doom-color 'red 256))
  `(org-agenda-date-today :foreground ,(doom-color 'violet 256)
                          :height 1.5
                          :weight bold
                          :inherit variable-pitch))

(after! org-agenda
  (add-hook 'org-agenda-mode-hook #'my-org-agenda-buffer-config-h)
  (add-hook 'org-agenda-finalize-hook #'my-org-agenda-setup-time-grid-h)
  (add-hook 'window-state-change-hook #'my-bring-org-agenda-to-front-h)
  (remove-hook 'org-agenda-finalize-hook '+org-exclude-agenda-buffers-from-workspace-h)
  (remove-hook 'org-agenda-finalize-hook '+org-defer-mode-in-agenda-buffers-h))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil-org-agenda
  (map! :map evil-org-agenda-mode-map
        :nvm [return] #'org-agenda-goto
        :nvm "RET" #'org-agenda-goto
        :nvm "j" #'org-agenda-next-item
        :nvm "l" #'org-agenda-next-item
        :nvm "k" #'org-agenda-previous-item
        :nvm "h" #'org-agenda-previous-item
        :nvm "<DOWN>" #'org-agenda-next-item
        :nvm "<RIGHT>" #'org-agenda-next-item
        :nvm "<UP>" #'org-agenda-previous-item
        :nvm "<LEFT>" #'org-agenda-previous-item
        :nvm [down] #'org-agenda-next-item
        :nvm [right] #'org-agenda-next-item
        :nvm [up] #'org-agenda-previous-item
        :nvm [left] #'org-agenda-previous-item
        :nvm "C-h" #'evil-window-left
        :nvm "C-j" #'evil-window-down
        :nvm "C-k" #'evil-window-up
        :nvm "C-l" #'evil-window-right
        :nvm "G" #'(lambda ()
                     (interactive)
                     (goto-char (point-max)) (org-agenda-previous-item 1))
        (:prefix ("g" . "goto")
         :desc "Go to first item" :nvm "g" #'(lambda ()
                                               (interactive)
                                               (goto-char (point-min))
                                               (org-agenda-next-item 1)))))
#+end_src

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
(package! org-ql)
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-org-agenda-make-agenda-icon-header-a (func name)
  :around 'org-super-agenda--make-agenda-header
  (let ((icon (get-text-property 0 'icon name))
        (icon-color (get-text-property 0 'icon-color name))
        (header (s-trim (funcall func name))))
    (concat
     "\n"
     (when icon
       (format "%s " (my-icon icon icon-color)))
     header
     "\n"
     (if icon
         (s-repeat (+ 3 (length header)) "─")
       (s-repeat (length header) "─")))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-org-agenda-group-title (text &optional icon icon-color)
  (propertize text 'icon icon 'icon-color icon-color))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-agenda)
  :init
  (setq org-agenda-custom-commands
        '(("c" "Super view"
           ((agenda "" ((org-agenda-span 'day)
                        (org-agenda-start-day (format-time-string "%Y-%m-%d"))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline))
                        (org-agenda-show-all-dates t)
                        (org-agenda-use-time-grid t)
                        (org-agenda-overriding-header "")
                        (org-super-agenda-groups
                         `((:name ,(my-org-agenda-group-title "Agenda" 'calendar (doom-lighten 'blue 0.5))
                            :time-grid t
                            :and (:date today
                                  :todo nil))))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          `(
                            (:name ,(my-org-agenda-group-title "Inbox" 'inbox (doom-color 'orange))
                             :category "journal"
                             :order 15)
                            (:name ,(my-org-agenda-group-title "Delegated" 'assign (doom-color 'orange))
                             :todo "DELG"
                             :order 45)
                            (:name ,(my-org-agenda-group-title "Waiting" 'wait  (doom-color 'yellow))
                             :todo "WAIT"
                             :order 35)
                            (:name ,(my-org-agenda-group-title "On Hold" 'pause (doom-color 'yellow))
                             :todo "HOLD"
                             :order 40)
                            (:name ,(my-org-agenda-group-title "Issues" 'bug (doom-color 'red))
                             :tag "issue"
                             :order 30)
                            (:name ,(my-org-agenda-group-title "Habits" 'loop (doom-color 'blue))
                             :habit t
                             :order 1)
                            (:name ,(my-org-agenda-group-title "Overdue" 'busy (doom-color 'red))
                             :deadline past
                             :face 'all-the-icons-dpink
                             :order 4)
                            (:name ,(my-org-agenda-group-title "Due Today" 'new (doom-color 'orange))
                             :deadline today
                             :face 'all-the-icons-orange
                             :order 5)
                            (:name ,(my-org-agenda-group-title "Actionable" 'checked (doom-color 'green))
                             :and (:todo ("TODO" "STRT")
                                   :scheduled (past today)
                                   :deadline nil)
                             :order 21)
                            (:name ,(my-org-agenda-group-title "Due Soon" 'snooze (doom-color 'yellow))
                             :deadline future
                             :face 'all-the-icons-yellow
                             :order 10)
                            (:name ,(my-org-agenda-group-title "Important" 'error (doom-color 'red))
                             :priority "A"
                             :order 15)
                            (:name ,(my-org-agenda-group-title "Next to do" 'visibility (doom-color 'yellow))
                             :todo "NEXT"
                             :order 20)
                            (:name ,(my-org-agenda-group-title "To do" 'checked (doom-color 'green))
                             :anything t
                             :order 23)
                            ))))))))
  :config
  (setq org-super-agenda-header-map nil)
  (org-super-agenda-mode))
#+end_src

* Appendix

** The =init.el= file
We can't tangle the =init.el= on Doom because it is always loaded before =doom sync= starts tangling =config.org=.

I have two alternatives here:

1. Let =init.el= as a lisp package;
2. Create a =doom sync= extension to tangle a =init.org= file;

For now, I will keep it as a separated Lisp file that I'm reproducing in this appendix for sake of documentation:

#+caption: $DOOMDIR/init.el
#+include: "~/.config/doom/init.el" src emacs-lisp :tangle no
